{"ast":null,"code":"'use strict';\n\nvar Parser = require('jsonparse'),\n    through = require('through');\n\nvar bufferFrom = Buffer.from && Buffer.from !== Uint8Array.from;\n/*\r\n\r\n  the value of this.stack that creationix's jsonparse has is weird.\r\n\r\n  it makes this code ugly, but his problem is way harder that mine,\r\n  so i'll forgive him.\r\n\r\n*/\n\nexports.parse = function (path, map) {\n  var header, footer;\n  var parser = new Parser();\n  var stream = through(function (chunk) {\n    if ('string' === typeof chunk) chunk = bufferFrom ? Buffer.from(chunk) : new Buffer(chunk);\n    parser.write(chunk);\n  }, function (data) {\n    if (data) stream.write(data);\n    if (header) stream.emit('header', header);\n    if (footer) stream.emit('footer', footer);\n    stream.queue(null);\n  });\n  if ('string' === typeof path) path = path.split('.').map(function (e) {\n    if (e === '$*') return {\n      emitKey: true\n    };else if (e === '*') return true;else if (e === '') // '..'.split('.') returns an empty string\n      return {\n        recurse: true\n      };else return e;\n  });\n\n  var count = 0,\n      _key;\n\n  if (!path || !path.length) path = null;\n\n  parser.onValue = function (value) {\n    if (!this.root) stream.root = value;\n    if (!path) return;\n    var i = 0; // iterates on path\n\n    var j = 0; // iterates on stack\n\n    var emitKey = false;\n    var emitPath = false;\n\n    while (i < path.length) {\n      var key = path[i];\n      var c;\n      j++;\n\n      if (key && !key.recurse) {\n        c = j === this.stack.length ? this : this.stack[j];\n        if (!c) return;\n\n        if (!check(key, c.key)) {\n          setHeaderFooter(c.key, value);\n          return;\n        }\n\n        emitKey = !!key.emitKey;\n        emitPath = !!key.emitPath;\n        i++;\n      } else {\n        i++;\n        var nextKey = path[i];\n        if (!nextKey) return;\n\n        while (true) {\n          c = j === this.stack.length ? this : this.stack[j];\n          if (!c) return;\n\n          if (check(nextKey, c.key)) {\n            i++;\n            if (!Object.isFrozen(this.stack[j])) this.stack[j].value = null;\n            break;\n          } else {\n            setHeaderFooter(c.key, value);\n          }\n\n          j++;\n        }\n      }\n    } // emit header\n\n\n    if (header) {\n      stream.emit('header', header);\n      header = false;\n    }\n\n    if (j !== this.stack.length) return;\n    count++;\n    var actualPath = this.stack.slice(1).map(function (element) {\n      return element.key;\n    }).concat([this.key]);\n    var data = value;\n    if (null != data) if (null != (data = map ? map(data, actualPath) : data)) {\n      if (emitKey || emitPath) {\n        data = {\n          value: data\n        };\n        if (emitKey) data[\"key\"] = this.key;\n        if (emitPath) data[\"path\"] = actualPath;\n      }\n\n      stream.queue(data);\n    }\n    if (this.value) delete this.value[this.key];\n\n    for (var k in this.stack) if (!Object.isFrozen(this.stack[k])) this.stack[k].value = null;\n  };\n\n  parser._onToken = parser.onToken;\n\n  parser.onToken = function (token, value) {\n    parser._onToken(token, value);\n\n    if (this.stack.length === 0) {\n      if (stream.root) {\n        if (!path) stream.queue(stream.root);\n        count = 0;\n        stream.root = null;\n      }\n    }\n  };\n\n  parser.onError = function (err) {\n    if (err.message.indexOf(\"at position\") > -1) err.message = \"Invalid JSON (\" + err.message + \")\";\n    stream.emit('error', err);\n  };\n\n  return stream;\n\n  function setHeaderFooter(key, value) {\n    // header has not been emitted yet\n    if (header !== false) {\n      header = header || {};\n      header[key] = value;\n    } // footer has not been emitted yet but header has\n\n\n    if (footer !== false && header === false) {\n      footer = footer || {};\n      footer[key] = value;\n    }\n  }\n};\n\nfunction check(x, y) {\n  if ('string' === typeof x) return y == x;else if (x && 'function' === typeof x.exec) return x.exec(y);else if ('boolean' === typeof x || 'object' === typeof x) return x;else if ('function' === typeof x) return x(y);\n  return false;\n}\n\nexports.stringify = function (op, sep, cl, indent) {\n  indent = indent || 0;\n\n  if (op === false) {\n    op = '';\n    sep = '\\n';\n    cl = '';\n  } else if (op == null) {\n    op = '[\\n';\n    sep = '\\n,\\n';\n    cl = '\\n]\\n';\n  } //else, what ever you like\n\n\n  var stream,\n      first = true,\n      anyData = false;\n  stream = through(function (data) {\n    anyData = true;\n\n    try {\n      var json = JSON.stringify(data, null, indent);\n    } catch (err) {\n      return stream.emit('error', err);\n    }\n\n    if (first) {\n      first = false;\n      stream.queue(op + json);\n    } else stream.queue(sep + json);\n  }, function (data) {\n    if (!anyData) stream.queue(op);\n    stream.queue(cl);\n    stream.queue(null);\n  });\n  return stream;\n};\n\nexports.stringifyObject = function (op, sep, cl, indent) {\n  indent = indent || 0;\n\n  if (op === false) {\n    op = '';\n    sep = '\\n';\n    cl = '';\n  } else if (op == null) {\n    op = '{\\n';\n    sep = '\\n,\\n';\n    cl = '\\n}\\n';\n  } //else, what ever you like\n\n\n  var first = true;\n  var anyData = false;\n  var stream = through(function (data) {\n    anyData = true;\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent);\n\n    if (first) {\n      first = false;\n      this.queue(op + json);\n    } else this.queue(sep + json);\n  }, function (data) {\n    if (!anyData) this.queue(op);\n    this.queue(cl);\n    this.queue(null);\n  });\n  return stream;\n};","map":{"version":3,"sources":["D:/node_modules/npm/node_modules/JSONStream/index.js"],"names":["Parser","require","through","bufferFrom","Buffer","from","Uint8Array","exports","parse","path","map","header","footer","parser","stream","chunk","write","data","emit","queue","split","e","emitKey","recurse","count","_key","length","onValue","value","root","i","j","emitPath","key","c","stack","check","setHeaderFooter","nextKey","Object","isFrozen","actualPath","slice","element","concat","k","_onToken","onToken","token","onError","err","message","indexOf","x","y","exec","stringify","op","sep","cl","indent","first","anyData","json","JSON","stringifyObject"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nvar Parser = require('jsonparse')\r\n  , through = require('through')\r\n\r\nvar bufferFrom = Buffer.from && Buffer.from !== Uint8Array.from\r\n\r\n/*\r\n\r\n  the value of this.stack that creationix's jsonparse has is weird.\r\n\r\n  it makes this code ugly, but his problem is way harder that mine,\r\n  so i'll forgive him.\r\n\r\n*/\r\n\r\nexports.parse = function (path, map) {\r\n  var header, footer\r\n  var parser = new Parser()\r\n  var stream = through(function (chunk) {\r\n    if('string' === typeof chunk)\r\n      chunk = bufferFrom ? Buffer.from(chunk) : new Buffer(chunk)\r\n    parser.write(chunk)\r\n  },\r\n  function (data) {\r\n    if(data)\r\n      stream.write(data)\r\n    if (header)\r\n        stream.emit('header', header)\r\n    if (footer)\r\n      stream.emit('footer', footer)\r\n    stream.queue(null)\r\n  })\r\n\r\n  if('string' === typeof path)\r\n    path = path.split('.').map(function (e) {\r\n      if (e === '$*')\r\n        return {emitKey: true}\r\n      else if (e === '*')\r\n        return true\r\n      else if (e === '') // '..'.split('.') returns an empty string\r\n        return {recurse: true}\r\n      else\r\n        return e\r\n    })\r\n\r\n\r\n  var count = 0, _key\r\n  if(!path || !path.length)\r\n    path = null\r\n\r\n  parser.onValue = function (value) {\r\n    if (!this.root)\r\n      stream.root = value\r\n\r\n    if(! path) return\r\n\r\n    var i = 0 // iterates on path\r\n    var j  = 0 // iterates on stack\r\n    var emitKey = false;\r\n    var emitPath = false;\r\n    while (i < path.length) {\r\n      var key = path[i]\r\n      var c\r\n      j++\r\n\r\n      if (key && !key.recurse) {\r\n        c = (j === this.stack.length) ? this : this.stack[j]\r\n        if (!c) return\r\n        if (! check(key, c.key)) {\r\n          setHeaderFooter(c.key, value)\r\n          return\r\n        }\r\n        emitKey = !!key.emitKey;\r\n        emitPath = !!key.emitPath;\r\n        i++\r\n      } else {\r\n        i++\r\n        var nextKey = path[i]\r\n        if (! nextKey) return\r\n        while (true) {\r\n          c = (j === this.stack.length) ? this : this.stack[j]\r\n          if (!c) return\r\n          if (check(nextKey, c.key)) {\r\n            i++;\r\n            if (!Object.isFrozen(this.stack[j]))\r\n              this.stack[j].value = null\r\n            break\r\n          } else {\r\n            setHeaderFooter(c.key, value)\r\n          }\r\n          j++\r\n        }\r\n      }\r\n\r\n    }\r\n\r\n    // emit header\r\n    if (header) {\r\n      stream.emit('header', header);\r\n      header = false;\r\n    }\r\n    if (j !== this.stack.length) return\r\n\r\n    count ++\r\n    var actualPath = this.stack.slice(1).map(function(element) { return element.key }).concat([this.key])\r\n    var data = value\r\n    if(null != data)\r\n      if(null != (data = map ? map(data, actualPath) : data)) {\r\n        if (emitKey || emitPath) {\r\n          data = { value: data };\r\n          if (emitKey)\r\n            data[\"key\"] = this.key;\r\n          if (emitPath)\r\n            data[\"path\"] = actualPath;\r\n        }\r\n\r\n        stream.queue(data)\r\n      }\r\n    if (this.value) delete this.value[this.key]\r\n    for(var k in this.stack)\r\n      if (!Object.isFrozen(this.stack[k]))\r\n        this.stack[k].value = null\r\n  }\r\n  parser._onToken = parser.onToken;\r\n\r\n  parser.onToken = function (token, value) {\r\n    parser._onToken(token, value);\r\n    if (this.stack.length === 0) {\r\n      if (stream.root) {\r\n        if(!path)\r\n          stream.queue(stream.root)\r\n        count = 0;\r\n        stream.root = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  parser.onError = function (err) {\r\n    if(err.message.indexOf(\"at position\") > -1)\r\n      err.message = \"Invalid JSON (\" + err.message + \")\";\r\n    stream.emit('error', err)\r\n  }\r\n\r\n  return stream\r\n\r\n  function setHeaderFooter(key, value) {\r\n    // header has not been emitted yet\r\n    if (header !== false) {\r\n      header = header || {}\r\n      header[key] = value\r\n    }\r\n\r\n    // footer has not been emitted yet but header has\r\n    if (footer !== false && header === false) {\r\n      footer = footer || {}\r\n      footer[key] = value\r\n    }\r\n  }\r\n}\r\n\r\nfunction check (x, y) {\r\n  if ('string' === typeof x)\r\n    return y == x\r\n  else if (x && 'function' === typeof x.exec)\r\n    return x.exec(y)\r\n  else if ('boolean' === typeof x || 'object' === typeof x)\r\n    return x\r\n  else if ('function' === typeof x)\r\n    return x(y)\r\n  return false\r\n}\r\n\r\nexports.stringify = function (op, sep, cl, indent) {\r\n  indent = indent || 0\r\n  if (op === false){\r\n    op = ''\r\n    sep = '\\n'\r\n    cl = ''\r\n  } else if (op == null) {\r\n\r\n    op = '[\\n'\r\n    sep = '\\n,\\n'\r\n    cl = '\\n]\\n'\r\n\r\n  }\r\n\r\n  //else, what ever you like\r\n\r\n  var stream\r\n    , first = true\r\n    , anyData = false\r\n  stream = through(function (data) {\r\n    anyData = true\r\n    try {\r\n      var json = JSON.stringify(data, null, indent)\r\n    } catch (err) {\r\n      return stream.emit('error', err)\r\n    }\r\n    if(first) { first = false ; stream.queue(op + json)}\r\n    else stream.queue(sep + json)\r\n  },\r\n  function (data) {\r\n    if(!anyData)\r\n      stream.queue(op)\r\n    stream.queue(cl)\r\n    stream.queue(null)\r\n  })\r\n\r\n  return stream\r\n}\r\n\r\nexports.stringifyObject = function (op, sep, cl, indent) {\r\n  indent = indent || 0\r\n  if (op === false){\r\n    op = ''\r\n    sep = '\\n'\r\n    cl = ''\r\n  } else if (op == null) {\r\n\r\n    op = '{\\n'\r\n    sep = '\\n,\\n'\r\n    cl = '\\n}\\n'\r\n\r\n  }\r\n\r\n  //else, what ever you like\r\n\r\n  var first = true\r\n  var anyData = false\r\n  var stream = through(function (data) {\r\n    anyData = true\r\n    var json = JSON.stringify(data[0]) + ':' + JSON.stringify(data[1], null, indent)\r\n    if(first) { first = false ; this.queue(op + json)}\r\n    else this.queue(sep + json)\r\n  },\r\n  function (data) {\r\n    if(!anyData) this.queue(op)\r\n    this.queue(cl)\r\n\r\n    this.queue(null)\r\n  })\r\n\r\n  return stream\r\n}\r\n\r\n\r\n"]},"metadata":{},"sourceType":"script"}