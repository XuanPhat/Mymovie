{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst utils_1 = require(\"./utils\"); // The default Buffer size if one is not provided.\n\n\nconst DEFAULT_SMARTBUFFER_SIZE = 4096; // The default string encoding to use for reading/writing strings.\n\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\n\nclass SmartBuffer {\n  /**\r\n   * Creates a new SmartBuffer instance.\r\n   *\r\n   * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\r\n   */\n  constructor(options) {\n    this.length = 0;\n    this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n    this._writeOffset = 0;\n    this._readOffset = 0;\n\n    if (SmartBuffer.isSmartBufferOptions(options)) {\n      // Checks for encoding\n      if (options.encoding) {\n        utils_1.checkEncoding(options.encoding);\n        this._encoding = options.encoding;\n      } // Checks for initial size length\n\n\n      if (options.size) {\n        if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n          this._buff = Buffer.allocUnsafe(options.size);\n        } else {\n          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n        } // Check for initial Buffer\n\n      } else if (options.buff) {\n        if (options.buff instanceof Buffer) {\n          this._buff = options.buff;\n          this.length = options.buff.length;\n        } else {\n          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n        }\n      } else {\n        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n      }\n    } else {\n      // If something was passed but it's not a SmartBufferOptions object\n      if (typeof options !== 'undefined') {\n        throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n      } // Otherwise default to sane options\n\n\n      this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n    }\n  }\n  /**\r\n   * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\r\n   *\r\n   * @param size { Number } The size of the internal Buffer.\r\n   * @param encoding { String } The BufferEncoding to use for strings.\r\n   *\r\n   * @return { SmartBuffer }\r\n   */\n\n\n  static fromSize(size, encoding) {\n    return new this({\n      size: size,\n      encoding: encoding\n    });\n  }\n  /**\r\n   * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\r\n   *\r\n   * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\r\n   * @param encoding { String } The BufferEncoding to use for strings.\r\n   *\r\n   * @return { SmartBuffer }\r\n   */\n\n\n  static fromBuffer(buff, encoding) {\n    return new this({\n      buff: buff,\n      encoding: encoding\n    });\n  }\n  /**\r\n   * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\r\n   *\r\n   * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\r\n   */\n\n\n  static fromOptions(options) {\n    return new this(options);\n  }\n  /**\r\n   * Type checking function that determines if an object is a SmartBufferOptions object.\r\n   */\n\n\n  static isSmartBufferOptions(options) {\n    const castOptions = options;\n    return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);\n  } // Signed integers\n\n  /**\r\n   * Reads an Int8 value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readInt8(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n  }\n  /**\r\n   * Reads an Int16BE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readInt16BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n  }\n  /**\r\n   * Reads an Int16LE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readInt16LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n  }\n  /**\r\n   * Reads an Int32BE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readInt32BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n  }\n  /**\r\n   * Reads an Int32LE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readInt32LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n  }\n  /**\r\n   * Reads a BigInt64BE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { BigInt }\r\n   */\n\n\n  readBigInt64BE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\n    return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n  }\n  /**\r\n   * Reads a BigInt64LE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { BigInt }\r\n   */\n\n\n  readBigInt64LE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\n    return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n  }\n  /**\r\n   * Writes an Int8 value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeInt8(value, offset) {\n    this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n\n    return this;\n  }\n  /**\r\n   * Inserts an Int8 value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertInt8(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n  }\n  /**\r\n   * Writes an Int16BE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeInt16BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n  }\n  /**\r\n   * Inserts an Int16BE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertInt16BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n  }\n  /**\r\n   * Writes an Int16LE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeInt16LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n  }\n  /**\r\n   * Inserts an Int16LE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertInt16LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n  }\n  /**\r\n   * Writes an Int32BE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeInt32BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n  }\n  /**\r\n   * Inserts an Int32BE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertInt32BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n  }\n  /**\r\n   * Writes an Int32LE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeInt32LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n  }\n  /**\r\n   * Inserts an Int32LE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertInt32LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n  }\n  /**\r\n   * Writes a BigInt64BE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { BigInt } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeBigInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n    return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n  }\n  /**\r\n   * Inserts a BigInt64BE value at the given offset value.\r\n   *\r\n   * @param value { BigInt } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertBigInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n    return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n  }\n  /**\r\n   * Writes a BigInt64LE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { BigInt } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeBigInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n    return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n  }\n  /**\r\n   * Inserts a Int64LE value at the given offset value.\r\n   *\r\n   * @param value { BigInt } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertBigInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n    return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n  } // Unsigned Integers\n\n  /**\r\n   * Reads an UInt8 value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readUInt8(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n  }\n  /**\r\n   * Reads an UInt16BE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readUInt16BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n  }\n  /**\r\n   * Reads an UInt16LE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readUInt16LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n  }\n  /**\r\n   * Reads an UInt32BE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readUInt32BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n  }\n  /**\r\n   * Reads an UInt32LE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readUInt32LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n  }\n  /**\r\n   * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { BigInt }\r\n   */\n\n\n  readBigUInt64BE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\n    return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n  }\n  /**\r\n   * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { BigInt }\r\n   */\n\n\n  readBigUInt64LE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\n    return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n  }\n  /**\r\n   * Writes an UInt8 value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeUInt8(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n  }\n  /**\r\n   * Inserts an UInt8 value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertUInt8(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n  }\n  /**\r\n   * Writes an UInt16BE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeUInt16BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n  }\n  /**\r\n   * Inserts an UInt16BE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertUInt16BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n  }\n  /**\r\n   * Writes an UInt16LE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeUInt16LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n  }\n  /**\r\n   * Inserts an UInt16LE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertUInt16LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n  }\n  /**\r\n   * Writes an UInt32BE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeUInt32BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n  }\n  /**\r\n   * Inserts an UInt32BE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertUInt32BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n  }\n  /**\r\n   * Writes an UInt32LE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeUInt32LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n  }\n  /**\r\n   * Inserts an UInt32LE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertUInt32LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n  }\n  /**\r\n   * Writes a BigUInt64BE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeBigUInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n    return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n  }\n  /**\r\n   * Inserts a BigUInt64BE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertBigUInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n    return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n  }\n  /**\r\n   * Writes a BigUInt64LE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeBigUInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n    return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n  }\n  /**\r\n   * Inserts a BigUInt64LE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertBigUInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n    return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n  } // Floating Point\n\n  /**\r\n   * Reads an FloatBE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readFloatBE(offset) {\n    return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n  }\n  /**\r\n   * Reads an FloatLE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readFloatLE(offset) {\n    return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n  }\n  /**\r\n   * Writes a FloatBE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeFloatBE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n  }\n  /**\r\n   * Inserts a FloatBE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertFloatBE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n  }\n  /**\r\n   * Writes a FloatLE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeFloatLE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n  }\n  /**\r\n   * Inserts a FloatLE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertFloatLE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n  } // Double Floating Point\n\n  /**\r\n   * Reads an DoublEBE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readDoubleBE(offset) {\n    return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n  }\n  /**\r\n   * Reads an DoubleLE value from the current read position or an optionally provided offset.\r\n   *\r\n   * @param offset { Number } The offset to read data from (optional)\r\n   * @return { Number }\r\n   */\n\n\n  readDoubleLE(offset) {\n    return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n  }\n  /**\r\n   * Writes a DoubleBE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeDoubleBE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n  }\n  /**\r\n   * Inserts a DoubleBE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertDoubleBE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n  }\n  /**\r\n   * Writes a DoubleLE value to the current write position (or at optional offset).\r\n   *\r\n   * @param value { Number } The value to write.\r\n   * @param offset { Number } The offset to write the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeDoubleLE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n  }\n  /**\r\n   * Inserts a DoubleLE value at the given offset value.\r\n   *\r\n   * @param value { Number } The value to insert.\r\n   * @param offset { Number } The offset to insert the value at.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertDoubleLE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n  } // Strings\n\n  /**\r\n   * Reads a String from the current read position.\r\n   *\r\n   * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\r\n   *             the string (Defaults to instance level encoding).\r\n   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\r\n   *\r\n   * @return { String }\r\n   */\n\n\n  readString(arg1, encoding) {\n    let lengthVal; // Length provided\n\n    if (typeof arg1 === 'number') {\n      utils_1.checkLengthValue(arg1);\n      lengthVal = Math.min(arg1, this.length - this._readOffset);\n    } else {\n      encoding = arg1;\n      lengthVal = this.length - this._readOffset;\n    } // Check encoding\n\n\n    if (typeof encoding !== 'undefined') {\n      utils_1.checkEncoding(encoding);\n    }\n\n    const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n\n    this._readOffset += lengthVal;\n    return value;\n  }\n  /**\r\n   * Inserts a String\r\n   *\r\n   * @param value { String } The String value to insert.\r\n   * @param offset { Number } The offset to insert the string at.\r\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertString(value, offset, encoding) {\n    utils_1.checkOffsetValue(offset);\n    return this._handleString(value, true, offset, encoding);\n  }\n  /**\r\n   * Writes a String\r\n   *\r\n   * @param value { String } The String value to write.\r\n   * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\r\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeString(value, arg2, encoding) {\n    return this._handleString(value, false, arg2, encoding);\n  }\n  /**\r\n   * Reads a null-terminated String from the current read position.\r\n   *\r\n   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\r\n   *\r\n   * @return { String }\r\n   */\n\n\n  readStringNT(encoding) {\n    if (typeof encoding !== 'undefined') {\n      utils_1.checkEncoding(encoding);\n    } // Set null character position to the end SmartBuffer instance.\n\n\n    let nullPos = this.length; // Find next null character (if one is not found, default from above is used)\n\n    for (let i = this._readOffset; i < this.length; i++) {\n      if (this._buff[i] === 0x00) {\n        nullPos = i;\n        break;\n      }\n    } // Read string value\n\n\n    const value = this._buff.slice(this._readOffset, nullPos); // Increment internal Buffer read offset\n\n\n    this._readOffset = nullPos + 1;\n    return value.toString(encoding || this._encoding);\n  }\n  /**\r\n   * Inserts a null-terminated String.\r\n   *\r\n   * @param value { String } The String value to write.\r\n   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\r\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertStringNT(value, offset, encoding) {\n    utils_1.checkOffsetValue(offset); // Write Values\n\n    this.insertString(value, offset, encoding);\n    this.insertUInt8(0x00, offset + value.length);\n    return this;\n  }\n  /**\r\n   * Writes a null-terminated String.\r\n   *\r\n   * @param value { String } The String value to write.\r\n   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\r\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeStringNT(value, arg2, encoding) {\n    // Write Values\n    this.writeString(value, arg2, encoding);\n    this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n    return this;\n  } // Buffers\n\n  /**\r\n   * Reads a Buffer from the internal read position.\r\n   *\r\n   * @param length { Number } The length of data to read as a Buffer.\r\n   *\r\n   * @return { Buffer }\r\n   */\n\n\n  readBuffer(length) {\n    if (typeof length !== 'undefined') {\n      utils_1.checkLengthValue(length);\n    }\n\n    const lengthVal = typeof length === 'number' ? length : this.length;\n    const endPoint = Math.min(this.length, this._readOffset + lengthVal); // Read buffer value\n\n    const value = this._buff.slice(this._readOffset, endPoint); // Increment internal Buffer read offset\n\n\n    this._readOffset = endPoint;\n    return value;\n  }\n  /**\r\n   * Writes a Buffer to the current write position.\r\n   *\r\n   * @param value { Buffer } The Buffer to write.\r\n   * @param offset { Number } The offset to write the Buffer to.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertBuffer(value, offset) {\n    utils_1.checkOffsetValue(offset);\n    return this._handleBuffer(value, true, offset);\n  }\n  /**\r\n   * Writes a Buffer to the current write position.\r\n   *\r\n   * @param value { Buffer } The Buffer to write.\r\n   * @param offset { Number } The offset to write the Buffer to.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeBuffer(value, offset) {\n    return this._handleBuffer(value, false, offset);\n  }\n  /**\r\n   * Reads a null-terminated Buffer from the current read poisiton.\r\n   *\r\n   * @return { Buffer }\r\n   */\n\n\n  readBufferNT() {\n    // Set null character position to the end SmartBuffer instance.\n    let nullPos = this.length; // Find next null character (if one is not found, default from above is used)\n\n    for (let i = this._readOffset; i < this.length; i++) {\n      if (this._buff[i] === 0x00) {\n        nullPos = i;\n        break;\n      }\n    } // Read value\n\n\n    const value = this._buff.slice(this._readOffset, nullPos); // Increment internal Buffer read offset\n\n\n    this._readOffset = nullPos + 1;\n    return value;\n  }\n  /**\r\n   * Inserts a null-terminated Buffer.\r\n   *\r\n   * @param value { Buffer } The Buffer to write.\r\n   * @param offset { Number } The offset to write the Buffer to.\r\n   *\r\n   * @return this\r\n   */\n\n\n  insertBufferNT(value, offset) {\n    utils_1.checkOffsetValue(offset); // Write Values\n\n    this.insertBuffer(value, offset);\n    this.insertUInt8(0x00, offset + value.length);\n    return this;\n  }\n  /**\r\n   * Writes a null-terminated Buffer.\r\n   *\r\n   * @param value { Buffer } The Buffer to write.\r\n   * @param offset { Number } The offset to write the Buffer to.\r\n   *\r\n   * @return this\r\n   */\n\n\n  writeBufferNT(value, offset) {\n    // Checks for valid numberic value;\n    if (typeof offset !== 'undefined') {\n      utils_1.checkOffsetValue(offset);\n    } // Write Values\n\n\n    this.writeBuffer(value, offset);\n    this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n    return this;\n  }\n  /**\r\n   * Clears the SmartBuffer instance to its original empty state.\r\n   */\n\n\n  clear() {\n    this._writeOffset = 0;\n    this._readOffset = 0;\n    this.length = 0;\n    return this;\n  }\n  /**\r\n   * Gets the remaining data left to be read from the SmartBuffer instance.\r\n   *\r\n   * @return { Number }\r\n   */\n\n\n  remaining() {\n    return this.length - this._readOffset;\n  }\n  /**\r\n   * Gets the current read offset value of the SmartBuffer instance.\r\n   *\r\n   * @return { Number }\r\n   */\n\n\n  get readOffset() {\n    return this._readOffset;\n  }\n  /**\r\n   * Sets the read offset value of the SmartBuffer instance.\r\n   *\r\n   * @param offset { Number } - The offset value to set.\r\n   */\n\n\n  set readOffset(offset) {\n    utils_1.checkOffsetValue(offset); // Check for bounds.\n\n    utils_1.checkTargetOffset(offset, this);\n    this._readOffset = offset;\n  }\n  /**\r\n   * Gets the current write offset value of the SmartBuffer instance.\r\n   *\r\n   * @return { Number }\r\n   */\n\n\n  get writeOffset() {\n    return this._writeOffset;\n  }\n  /**\r\n   * Sets the write offset value of the SmartBuffer instance.\r\n   *\r\n   * @param offset { Number } - The offset value to set.\r\n   */\n\n\n  set writeOffset(offset) {\n    utils_1.checkOffsetValue(offset); // Check for bounds.\n\n    utils_1.checkTargetOffset(offset, this);\n    this._writeOffset = offset;\n  }\n  /**\r\n   * Gets the currently set string encoding of the SmartBuffer instance.\r\n   *\r\n   * @return { BufferEncoding } The string Buffer encoding currently set.\r\n   */\n\n\n  get encoding() {\n    return this._encoding;\n  }\n  /**\r\n   * Sets the string encoding of the SmartBuffer instance.\r\n   *\r\n   * @param encoding { BufferEncoding } The string Buffer encoding to set.\r\n   */\n\n\n  set encoding(encoding) {\n    utils_1.checkEncoding(encoding);\n    this._encoding = encoding;\n  }\n  /**\r\n   * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\r\n   *\r\n   * @return { Buffer } The Buffer value.\r\n   */\n\n\n  get internalBuffer() {\n    return this._buff;\n  }\n  /**\r\n   * Gets the value of the internal managed Buffer (Includes managed data only)\r\n   *\r\n   * @param { Buffer }\r\n   */\n\n\n  toBuffer() {\n    return this._buff.slice(0, this.length);\n  }\n  /**\r\n   * Gets the String value of the internal managed Buffer\r\n   *\r\n   * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\r\n   */\n\n\n  toString(encoding) {\n    const encodingVal = typeof encoding === 'string' ? encoding : this._encoding; // Check for invalid encoding.\n\n    utils_1.checkEncoding(encodingVal);\n    return this._buff.toString(encodingVal, 0, this.length);\n  }\n  /**\r\n   * Destroys the SmartBuffer instance.\r\n   */\n\n\n  destroy() {\n    this.clear();\n    return this;\n  }\n  /**\r\n   * Handles inserting and writing strings.\r\n   *\r\n   * @param value { String } The String value to insert.\r\n   * @param isInsert { Boolean } True if inserting a string, false if writing.\r\n   * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\r\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n   */\n\n\n  _handleString(value, isInsert, arg3, encoding) {\n    let offsetVal = this._writeOffset;\n    let encodingVal = this._encoding; // Check for offset\n\n    if (typeof arg3 === 'number') {\n      offsetVal = arg3; // Check for encoding\n    } else if (typeof arg3 === 'string') {\n      utils_1.checkEncoding(arg3);\n      encodingVal = arg3;\n    } // Check for encoding (third param)\n\n\n    if (typeof encoding === 'string') {\n      utils_1.checkEncoding(encoding);\n      encodingVal = encoding;\n    } // Calculate bytelength of string.\n\n\n    const byteLength = Buffer.byteLength(value, encodingVal); // Ensure there is enough internal Buffer capacity.\n\n    if (isInsert) {\n      this.ensureInsertable(byteLength, offsetVal);\n    } else {\n      this._ensureWriteable(byteLength, offsetVal);\n    } // Write value\n\n\n    this._buff.write(value, offsetVal, byteLength, encodingVal); // Increment internal Buffer write offset;\n\n\n    if (isInsert) {\n      this._writeOffset += byteLength;\n    } else {\n      // If an offset was given, check to see if we wrote beyond the current writeOffset.\n      if (typeof arg3 === 'number') {\n        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n      } else {\n        // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n        this._writeOffset += byteLength;\n      }\n    }\n\n    return this;\n  }\n  /**\r\n   * Handles writing or insert of a Buffer.\r\n   *\r\n   * @param value { Buffer } The Buffer to write.\r\n   * @param offset { Number } The offset to write the Buffer to.\r\n   */\n\n\n  _handleBuffer(value, isInsert, offset) {\n    const offsetVal = typeof offset === 'number' ? offset : this._writeOffset; // Ensure there is enough internal Buffer capacity.\n\n    if (isInsert) {\n      this.ensureInsertable(value.length, offsetVal);\n    } else {\n      this._ensureWriteable(value.length, offsetVal);\n    } // Write buffer value\n\n\n    value.copy(this._buff, offsetVal); // Increment internal Buffer write offset;\n\n    if (isInsert) {\n      this._writeOffset += value.length;\n    } else {\n      // If an offset was given, check to see if we wrote beyond the current writeOffset.\n      if (typeof offset === 'number') {\n        this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n      } else {\n        // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n        this._writeOffset += value.length;\n      }\n    }\n\n    return this;\n  }\n  /**\r\n   * Ensures that the internal Buffer is large enough to read data.\r\n   *\r\n   * @param length { Number } The length of the data that needs to be read.\r\n   * @param offset { Number } The offset of the data that needs to be read.\r\n   */\n\n\n  ensureReadable(length, offset) {\n    // Offset value defaults to managed read offset.\n    let offsetVal = this._readOffset; // If an offset was provided, use it.\n\n    if (typeof offset !== 'undefined') {\n      // Checks for valid numberic value;\n      utils_1.checkOffsetValue(offset); // Overide with custom offset.\n\n      offsetVal = offset;\n    } // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n\n\n    if (offsetVal < 0 || offsetVal + length > this.length) {\n      throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n    }\n  }\n  /**\r\n   * Ensures that the internal Buffer is large enough to insert data.\r\n   *\r\n   * @param dataLength { Number } The length of the data that needs to be written.\r\n   * @param offset { Number } The offset of the data to be written.\r\n   */\n\n\n  ensureInsertable(dataLength, offset) {\n    // Checks for valid numberic value;\n    utils_1.checkOffsetValue(offset); // Ensure there is enough internal Buffer capacity.\n\n    this._ensureCapacity(this.length + dataLength); // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n\n\n    if (offset < this.length) {\n      this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n    } // Adjust tracked smart buffer length\n\n\n    if (offset + dataLength > this.length) {\n      this.length = offset + dataLength;\n    } else {\n      this.length += dataLength;\n    }\n  }\n  /**\r\n   * Ensures that the internal Buffer is large enough to write data.\r\n   *\r\n   * @param dataLength { Number } The length of the data that needs to be written.\r\n   * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\r\n   */\n\n\n  _ensureWriteable(dataLength, offset) {\n    const offsetVal = typeof offset === 'number' ? offset : this._writeOffset; // Ensure enough capacity to write data.\n\n    this._ensureCapacity(offsetVal + dataLength); // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n\n\n    if (offsetVal + dataLength > this.length) {\n      this.length = offsetVal + dataLength;\n    }\n  }\n  /**\r\n   * Ensures that the internal Buffer is large enough to write at least the given amount of data.\r\n   *\r\n   * @param minLength { Number } The minimum length of the data needs to be written.\r\n   */\n\n\n  _ensureCapacity(minLength) {\n    const oldLength = this._buff.length;\n\n    if (minLength > oldLength) {\n      let data = this._buff;\n      let newLength = oldLength * 3 / 2 + 1;\n\n      if (newLength < minLength) {\n        newLength = minLength;\n      }\n\n      this._buff = Buffer.allocUnsafe(newLength);\n      data.copy(this._buff, 0, 0, oldLength);\n    }\n  }\n  /**\r\n   * Reads a numeric number value using the provided function.\r\n   *\r\n   * @typeparam T { number | bigint } The type of the value to be read\r\n   *\r\n   * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\r\n   * @param byteSize { Number } The number of bytes read.\r\n   * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\r\n   *\r\n   * @returns { T } the number value\r\n   */\n\n\n  _readNumberValue(func, byteSize, offset) {\n    this.ensureReadable(byteSize, offset); // Call Buffer.readXXXX();\n\n    const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset); // Adjust internal read offset if an optional read offset was not provided.\n\n    if (typeof offset === 'undefined') {\n      this._readOffset += byteSize;\n    }\n\n    return value;\n  }\n  /**\r\n   * Inserts a numeric number value based on the given offset and value.\r\n   *\r\n   * @typeparam T { number | bigint } The type of the value to be written\r\n   *\r\n   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\r\n   * @param byteSize { Number } The number of bytes written.\r\n   * @param value { T } The number value to write.\r\n   * @param offset { Number } the offset to write the number at (REQUIRED).\r\n   *\r\n   * @returns SmartBuffer this buffer\r\n   */\n\n\n  _insertNumberValue(func, byteSize, value, offset) {\n    // Check for invalid offset values.\n    utils_1.checkOffsetValue(offset); // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n\n    this.ensureInsertable(byteSize, offset); // Call buffer.writeXXXX();\n\n    func.call(this._buff, value, offset); // Adjusts internally managed write offset.\n\n    this._writeOffset += byteSize;\n    return this;\n  }\n  /**\r\n   * Writes a numeric number value based on the given offset and value.\r\n   *\r\n   * @typeparam T { number | bigint } The type of the value to be written\r\n   *\r\n   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\r\n   * @param byteSize { Number } The number of bytes written.\r\n   * @param value { T } The number value to write.\r\n   * @param offset { Number } the offset to write the number at (REQUIRED).\r\n   *\r\n   * @returns SmartBuffer this buffer\r\n   */\n\n\n  _writeNumberValue(func, byteSize, value, offset) {\n    // If an offset was provided, validate it.\n    if (typeof offset === 'number') {\n      // Check if we're writing beyond the bounds of the managed data.\n      if (offset < 0) {\n        throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n      }\n\n      utils_1.checkOffsetValue(offset);\n    } // Default to writeOffset if no offset value was given.\n\n\n    const offsetVal = typeof offset === 'number' ? offset : this._writeOffset; // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n\n    this._ensureWriteable(byteSize, offsetVal);\n\n    func.call(this._buff, value, offsetVal); // If an offset was given, check to see if we wrote beyond the current writeOffset.\n\n    if (typeof offset === 'number') {\n      this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n    } else {\n      // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n      this._writeOffset += byteSize;\n    }\n\n    return this;\n  }\n\n}\n\nexports.SmartBuffer = SmartBuffer;","map":{"version":3,"sources":["../src/smartbuffer.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA,C,CAiBA;;;AACA,MAAM,wBAAwB,GAAW,IAAzC,C,CAEA;;AACA,MAAM,4BAA4B,GAAmB,MAArD;;AAEA,MAAM,WAAN,CAAiB;AAQf;;;;AAIG;AACH,EAAA,WAAA,CAAY,OAAZ,EAAwC;AAZjC,SAAA,MAAA,GAAiB,CAAjB;AAEC,SAAA,SAAA,GAA4B,4BAA5B;AAEA,SAAA,YAAA,GAAuB,CAAvB;AACA,SAAA,WAAA,GAAsB,CAAtB;;AAQN,QAAI,WAAW,CAAC,oBAAZ,CAAiC,OAAjC,CAAJ,EAA+C;AAC7C;AACA,UAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,QAAA,OAAA,CAAA,aAAA,CAAc,OAAO,CAAC,QAAtB;AACA,aAAK,SAAL,GAAiB,OAAO,CAAC,QAAzB;AACD,OAL4C,CAO7C;;;AACA,UAAI,OAAO,CAAC,IAAZ,EAAkB;AAChB,YAAI,OAAA,CAAA,eAAA,CAAgB,OAAO,CAAC,IAAxB,KAAiC,OAAO,CAAC,IAAR,GAAe,CAApD,EAAuD;AACrD,eAAK,KAAL,GAAa,MAAM,CAAC,WAAP,CAAmB,OAAO,CAAC,IAA3B,CAAb;AACD,SAFD,MAEO;AACL,gBAAM,IAAI,KAAJ,CAAU,OAAA,CAAA,MAAA,CAAO,wBAAjB,CAAN;AACD,SALe,CAMhB;;AACD,OAPD,MAOO,IAAI,OAAO,CAAC,IAAZ,EAAkB;AACvB,YAAI,OAAO,CAAC,IAAR,YAAwB,MAA5B,EAAoC;AAClC,eAAK,KAAL,GAAa,OAAO,CAAC,IAArB;AACA,eAAK,MAAL,GAAc,OAAO,CAAC,IAAR,CAAa,MAA3B;AACD,SAHD,MAGO;AACL,gBAAM,IAAI,KAAJ,CAAU,OAAA,CAAA,MAAA,CAAO,0BAAjB,CAAN;AACD;AACF,OAPM,MAOA;AACL,aAAK,KAAL,GAAa,MAAM,CAAC,WAAP,CAAmB,wBAAnB,CAAb;AACD;AACF,KAzBD,MAyBO;AACL;AACA,UAAI,OAAO,OAAP,KAAmB,WAAvB,EAAoC;AAClC,cAAM,IAAI,KAAJ,CAAU,OAAA,CAAA,MAAA,CAAO,0BAAjB,CAAN;AACD,OAJI,CAML;;;AACA,WAAK,KAAL,GAAa,MAAM,CAAC,WAAP,CAAmB,wBAAnB,CAAb;AACD;AACF;AAED;;;;;;;AAOG;;;AACmB,SAAR,QAAQ,CAAC,IAAD,EAAe,QAAf,EAAwC;AAC5D,WAAO,IAAI,IAAJ,CAAS;AACd,MAAA,IAAI,EAAE,IADQ;AAEd,MAAA,QAAQ,EAAE;AAFI,KAAT,CAAP;AAID;AAED;;;;;;;AAOG;;;AACqB,SAAV,UAAU,CAAC,IAAD,EAAe,QAAf,EAAwC;AAC9D,WAAO,IAAI,IAAJ,CAAS;AACd,MAAA,IAAI,EAAE,IADQ;AAEd,MAAA,QAAQ,EAAE;AAFI,KAAT,CAAP;AAID;AAED;;;;AAIG;;;AACsB,SAAX,WAAW,CAAC,OAAD,EAA4B;AACnD,WAAO,IAAI,IAAJ,CAAS,OAAT,CAAP;AACD;AAED;;AAEG;;;AACwB,SAApB,oBAAoB,CAAC,OAAD,EAA4B;AACrD,UAAM,WAAW,GAAuB,OAAxC;AAEA,WACE,WAAW,KACV,WAAW,CAAC,QAAZ,KAAyB,SAAzB,IAAsC,WAAW,CAAC,IAAZ,KAAqB,SAA3D,IAAwE,WAAW,CAAC,IAAZ,KAAqB,SADnF,CADb;AAID,GAnGc,CAqGf;;AAEA;;;;;AAKG;;;AACH,EAAA,QAAQ,CAAC,MAAD,EAAgB;AACtB,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,QAAvC,EAAiD,CAAjD,EAAoD,MAApD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,WAAW,CAAC,MAAD,EAAgB;AACzB,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,WAAvC,EAAoD,CAApD,EAAuD,MAAvD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,WAAW,CAAC,MAAD,EAAgB;AACzB,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,WAAvC,EAAoD,CAApD,EAAuD,MAAvD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,WAAW,CAAC,MAAD,EAAgB;AACzB,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,WAAvC,EAAoD,CAApD,EAAuD,MAAvD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,WAAW,CAAC,MAAD,EAAgB;AACzB,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,WAAvC,EAAoD,CAApD,EAAuD,MAAvD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,cAAc,CAAC,MAAD,EAAgB;AAC5B,IAAA,OAAA,CAAA,yBAAA,CAA0B,gBAA1B;AACA,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,cAAvC,EAAuD,CAAvD,EAA0D,MAA1D,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,cAAc,CAAC,MAAD,EAAgB;AAC5B,IAAA,OAAA,CAAA,yBAAA,CAA0B,gBAA1B;AACA,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,cAAvC,EAAuD,CAAvD,EAA0D,MAA1D,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,SAAS,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AACtC,SAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,SAAxC,EAAmD,CAAnD,EAAsD,KAAtD,EAA6D,MAA7D;;AACA,WAAO,IAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,UAAU,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AACtC,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,SAAzC,EAAoD,CAApD,EAAuD,KAAvD,EAA8D,MAA9D,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,YAAY,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AACzC,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,YAAxC,EAAsD,CAAtD,EAAyD,KAAzD,EAAgE,MAAhE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AACzC,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,YAAzC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,YAAY,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AACzC,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,YAAxC,EAAsD,CAAtD,EAAyD,KAAzD,EAAgE,MAAhE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AACzC,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,YAAzC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,YAAY,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AACzC,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,YAAxC,EAAsD,CAAtD,EAAyD,KAAzD,EAAgE,MAAhE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AACzC,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,YAAzC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,YAAY,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AACzC,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,YAAxC,EAAsD,CAAtD,EAAyD,KAAzD,EAAgE,MAAhE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AACzC,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,YAAzC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,eAAe,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC5C,IAAA,OAAA,CAAA,yBAAA,CAA0B,iBAA1B;AACA,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,eAAxC,EAAyD,CAAzD,EAA4D,KAA5D,EAAmE,MAAnE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,gBAAgB,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC5C,IAAA,OAAA,CAAA,yBAAA,CAA0B,iBAA1B;AACA,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,eAAzC,EAA0D,CAA1D,EAA6D,KAA7D,EAAoE,MAApE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,eAAe,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC5C,IAAA,OAAA,CAAA,yBAAA,CAA0B,iBAA1B;AACA,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,eAAxC,EAAyD,CAAzD,EAA4D,KAA5D,EAAmE,MAAnE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,gBAAgB,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC5C,IAAA,OAAA,CAAA,yBAAA,CAA0B,iBAA1B;AACA,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,eAAzC,EAA0D,CAA1D,EAA6D,KAA7D,EAAoE,MAApE,CAAP;AACD,GA1Vc,CA4Vf;;AAEA;;;;;AAKG;;;AACH,EAAA,SAAS,CAAC,MAAD,EAAgB;AACvB,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,SAAvC,EAAkD,CAAlD,EAAqD,MAArD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,YAAY,CAAC,MAAD,EAAgB;AAC1B,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,YAAvC,EAAqD,CAArD,EAAwD,MAAxD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,YAAY,CAAC,MAAD,EAAgB;AAC1B,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,YAAvC,EAAqD,CAArD,EAAwD,MAAxD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,YAAY,CAAC,MAAD,EAAgB;AAC1B,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,YAAvC,EAAqD,CAArD,EAAwD,MAAxD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,YAAY,CAAC,MAAD,EAAgB;AAC1B,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,YAAvC,EAAqD,CAArD,EAAwD,MAAxD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,eAAe,CAAC,MAAD,EAAgB;AAC7B,IAAA,OAAA,CAAA,yBAAA,CAA0B,iBAA1B;AACA,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,eAAvC,EAAwD,CAAxD,EAA2D,MAA3D,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,eAAe,CAAC,MAAD,EAAgB;AAC7B,IAAA,OAAA,CAAA,yBAAA,CAA0B,iBAA1B;AACA,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,eAAvC,EAAwD,CAAxD,EAA2D,MAA3D,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,UAAU,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AACvC,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,UAAxC,EAAoD,CAApD,EAAuD,KAAvD,EAA8D,MAA9D,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,WAAW,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AACvC,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,UAAzC,EAAqD,CAArD,EAAwD,KAAxD,EAA+D,MAA/D,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC1C,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,aAAxC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC1C,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,aAAzC,EAAwD,CAAxD,EAA2D,KAA3D,EAAkE,MAAlE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC1C,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,aAAxC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC1C,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,aAAzC,EAAwD,CAAxD,EAA2D,KAA3D,EAAkE,MAAlE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC1C,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,aAAxC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC1C,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,aAAzC,EAAwD,CAAxD,EAA2D,KAA3D,EAAkE,MAAlE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC1C,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,aAAxC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC1C,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,aAAzC,EAAwD,CAAxD,EAA2D,KAA3D,EAAkE,MAAlE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,gBAAgB,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC7C,IAAA,OAAA,CAAA,yBAAA,CAA0B,kBAA1B;AACA,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,gBAAxC,EAA0D,CAA1D,EAA6D,KAA7D,EAAoE,MAApE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,iBAAiB,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC7C,IAAA,OAAA,CAAA,yBAAA,CAA0B,kBAA1B;AACA,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,gBAAzC,EAA2D,CAA3D,EAA8D,KAA9D,EAAqE,MAArE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,gBAAgB,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC7C,IAAA,OAAA,CAAA,yBAAA,CAA0B,kBAA1B;AACA,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,gBAAxC,EAA0D,CAA1D,EAA6D,KAA7D,EAAoE,MAApE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,iBAAiB,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC7C,IAAA,OAAA,CAAA,yBAAA,CAA0B,kBAA1B;AACA,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,gBAAzC,EAA2D,CAA3D,EAA8D,KAA9D,EAAqE,MAArE,CAAP;AACD,GAhlBc,CAklBf;;AAEA;;;;;AAKG;;;AACH,EAAA,WAAW,CAAC,MAAD,EAAgB;AACzB,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,WAAvC,EAAoD,CAApD,EAAuD,MAAvD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,WAAW,CAAC,MAAD,EAAgB;AACzB,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,WAAvC,EAAoD,CAApD,EAAuD,MAAvD,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,YAAY,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AACzC,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,YAAxC,EAAsD,CAAtD,EAAyD,KAAzD,EAAgE,MAAhE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AACzC,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,YAAzC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,YAAY,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AACzC,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,YAAxC,EAAsD,CAAtD,EAAyD,KAAzD,EAAgE,MAAhE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AACzC,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,YAAzC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD,GAtpBc,CAwpBf;;AAEA;;;;;AAKG;;;AACH,EAAA,YAAY,CAAC,MAAD,EAAgB;AAC1B,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,YAAvC,EAAqD,CAArD,EAAwD,MAAxD,CAAP;AACD;AAED;;;;;AAKG;;;AACH,EAAA,YAAY,CAAC,MAAD,EAAgB;AAC1B,WAAO,KAAK,gBAAL,CAAsB,MAAM,CAAC,SAAP,CAAiB,YAAvC,EAAqD,CAArD,EAAwD,MAAxD,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC1C,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,aAAxC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC1C,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,aAAzC,EAAwD,CAAxD,EAA2D,KAA3D,EAAkE,MAAlE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC1C,WAAO,KAAK,iBAAL,CAAuB,MAAM,CAAC,SAAP,CAAiB,aAAxC,EAAuD,CAAvD,EAA0D,KAA1D,EAAiE,MAAjE,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC1C,WAAO,KAAK,kBAAL,CAAwB,MAAM,CAAC,SAAP,CAAiB,aAAzC,EAAwD,CAAxD,EAA2D,KAA3D,EAAkE,MAAlE,CAAP;AACD,GA5tBc,CA8tBf;;AAEA;;;;;;;;AAQG;;;AACH,EAAA,UAAU,CAAC,IAAD,EAAiC,QAAjC,EAA0D;AAClE,QAAI,SAAJ,CADkE,CAGlE;;AACA,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,MAAA,OAAA,CAAA,gBAAA,CAAiB,IAAjB;AACA,MAAA,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,IAAT,EAAe,KAAK,MAAL,GAAc,KAAK,WAAlC,CAAZ;AACD,KAHD,MAGO;AACL,MAAA,QAAQ,GAAG,IAAX;AACA,MAAA,SAAS,GAAG,KAAK,MAAL,GAAc,KAAK,WAA/B;AACD,KAViE,CAYlE;;;AACA,QAAI,OAAO,QAAP,KAAoB,WAAxB,EAAqC;AACnC,MAAA,OAAA,CAAA,aAAA,CAAc,QAAd;AACD;;AAED,UAAM,KAAK,GAAG,KAAK,KAAL,CAAW,KAAX,CAAiB,KAAK,WAAtB,EAAmC,KAAK,WAAL,GAAmB,SAAtD,EAAiE,QAAjE,CAA0E,QAAQ,IAAI,KAAK,SAA3F,CAAd;;AAEA,SAAK,WAAL,IAAoB,SAApB;AACA,WAAO,KAAP;AACD;AAED;;;;;;;;AAQG;;;AACH,EAAA,YAAY,CAAC,KAAD,EAAgB,MAAhB,EAAgC,QAAhC,EAAyD;AACnE,IAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB;AAEA,WAAO,KAAK,aAAL,CAAmB,KAAnB,EAA0B,IAA1B,EAAgC,MAAhC,EAAwC,QAAxC,CAAP;AACD;AAED;;;;;;;;AAQG;;;AACH,EAAA,WAAW,CAAC,KAAD,EAAgB,IAAhB,EAAgD,QAAhD,EAAyE;AAClF,WAAO,KAAK,aAAL,CAAmB,KAAnB,EAA0B,KAA1B,EAAiC,IAAjC,EAAuC,QAAvC,CAAP;AACD;AAED;;;;;;AAMG;;;AACH,EAAA,YAAY,CAAC,QAAD,EAA0B;AACpC,QAAI,OAAO,QAAP,KAAoB,WAAxB,EAAqC;AACnC,MAAA,OAAA,CAAA,aAAA,CAAc,QAAd;AACD,KAHmC,CAKpC;;;AACA,QAAI,OAAO,GAAG,KAAK,MAAnB,CANoC,CAQpC;;AACA,SAAK,IAAI,CAAC,GAAG,KAAK,WAAlB,EAA+B,CAAC,GAAG,KAAK,MAAxC,EAAgD,CAAC,EAAjD,EAAqD;AACnD,UAAI,KAAK,KAAL,CAAW,CAAX,MAAkB,IAAtB,EAA4B;AAC1B,QAAA,OAAO,GAAG,CAAV;AACA;AACD;AACF,KAdmC,CAgBpC;;;AACA,UAAM,KAAK,GAAG,KAAK,KAAL,CAAW,KAAX,CAAiB,KAAK,WAAtB,EAAmC,OAAnC,CAAd,CAjBoC,CAmBpC;;;AACA,SAAK,WAAL,GAAmB,OAAO,GAAG,CAA7B;AAEA,WAAO,KAAK,CAAC,QAAN,CAAe,QAAQ,IAAI,KAAK,SAAhC,CAAP;AACD;AAED;;;;;;;;AAQG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAgB,MAAhB,EAAgC,QAAhC,EAAyD;AACrE,IAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB,EADqE,CAGrE;;AACA,SAAK,YAAL,CAAkB,KAAlB,EAAyB,MAAzB,EAAiC,QAAjC;AACA,SAAK,WAAL,CAAiB,IAAjB,EAAuB,MAAM,GAAG,KAAK,CAAC,MAAtC;AACA,WAAO,IAAP;AACD;AAED;;;;;;;;AAQG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,IAAhB,EAAgD,QAAhD,EAAyE;AACpF;AACA,SAAK,WAAL,CAAiB,KAAjB,EAAwB,IAAxB,EAA8B,QAA9B;AACA,SAAK,UAAL,CAAgB,IAAhB,EAAsB,OAAO,IAAP,KAAgB,QAAhB,GAA2B,IAAI,GAAG,KAAK,CAAC,MAAxC,GAAiD,KAAK,WAA5E;AACA,WAAO,IAAP;AACD,GA51Bc,CA81Bf;;AAEA;;;;;;AAMG;;;AACH,EAAA,UAAU,CAAC,MAAD,EAAgB;AACxB,QAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;AACjC,MAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB;AACD;;AAED,UAAM,SAAS,GAAG,OAAO,MAAP,KAAkB,QAAlB,GAA6B,MAA7B,GAAsC,KAAK,MAA7D;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,MAAd,EAAsB,KAAK,WAAL,GAAmB,SAAzC,CAAjB,CANwB,CAQxB;;AACA,UAAM,KAAK,GAAG,KAAK,KAAL,CAAW,KAAX,CAAiB,KAAK,WAAtB,EAAmC,QAAnC,CAAd,CATwB,CAWxB;;;AACA,SAAK,WAAL,GAAmB,QAAnB;AACA,WAAO,KAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,YAAY,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AACxC,IAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB;AAEA,WAAO,KAAK,aAAL,CAAmB,KAAnB,EAA0B,IAA1B,EAAgC,MAAhC,CAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,WAAW,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AACxC,WAAO,KAAK,aAAL,CAAmB,KAAnB,EAA0B,KAA1B,EAAiC,MAAjC,CAAP;AACD;AAED;;;;AAIG;;;AACH,EAAA,YAAY,GAAA;AACV;AACA,QAAI,OAAO,GAAG,KAAK,MAAnB,CAFU,CAIV;;AACA,SAAK,IAAI,CAAC,GAAG,KAAK,WAAlB,EAA+B,CAAC,GAAG,KAAK,MAAxC,EAAgD,CAAC,EAAjD,EAAqD;AACnD,UAAI,KAAK,KAAL,CAAW,CAAX,MAAkB,IAAtB,EAA4B;AAC1B,QAAA,OAAO,GAAG,CAAV;AACA;AACD;AACF,KAVS,CAYV;;;AACA,UAAM,KAAK,GAAG,KAAK,KAAL,CAAW,KAAX,CAAiB,KAAK,WAAtB,EAAmC,OAAnC,CAAd,CAbU,CAeV;;;AACA,SAAK,WAAL,GAAmB,OAAO,GAAG,CAA7B;AACA,WAAO,KAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,cAAc,CAAC,KAAD,EAAgB,MAAhB,EAA8B;AAC1C,IAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB,EAD0C,CAG1C;;AACA,SAAK,YAAL,CAAkB,KAAlB,EAAyB,MAAzB;AACA,SAAK,WAAL,CAAiB,IAAjB,EAAuB,MAAM,GAAG,KAAK,CAAC,MAAtC;AAEA,WAAO,IAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,aAAa,CAAC,KAAD,EAAgB,MAAhB,EAA+B;AAC1C;AACA,QAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;AACjC,MAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB;AACD,KAJyC,CAM1C;;;AACA,SAAK,WAAL,CAAiB,KAAjB,EAAwB,MAAxB;AACA,SAAK,UAAL,CAAgB,IAAhB,EAAsB,OAAO,MAAP,KAAkB,QAAlB,GAA6B,MAAM,GAAG,KAAK,CAAC,MAA5C,GAAqD,KAAK,YAAhF;AAEA,WAAO,IAAP;AACD;AAED;;AAEG;;;AACH,EAAA,KAAK,GAAA;AACH,SAAK,YAAL,GAAoB,CAApB;AACA,SAAK,WAAL,GAAmB,CAAnB;AACA,SAAK,MAAL,GAAc,CAAd;AACA,WAAO,IAAP;AACD;AAED;;;;AAIG;;;AACH,EAAA,SAAS,GAAA;AACP,WAAO,KAAK,MAAL,GAAc,KAAK,WAA1B;AACD;AAED;;;;AAIG;;;AACW,MAAV,UAAU,GAAA;AACZ,WAAO,KAAK,WAAZ;AACD;AAED;;;;AAIG;;;AACW,MAAV,UAAU,CAAC,MAAD,EAAe;AAC3B,IAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB,EAD2B,CAG3B;;AACA,IAAA,OAAA,CAAA,iBAAA,CAAkB,MAAlB,EAA0B,IAA1B;AAEA,SAAK,WAAL,GAAmB,MAAnB;AACD;AAED;;;;AAIG;;;AACY,MAAX,WAAW,GAAA;AACb,WAAO,KAAK,YAAZ;AACD;AAED;;;;AAIG;;;AACY,MAAX,WAAW,CAAC,MAAD,EAAe;AAC5B,IAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB,EAD4B,CAG5B;;AACA,IAAA,OAAA,CAAA,iBAAA,CAAkB,MAAlB,EAA0B,IAA1B;AAEA,SAAK,YAAL,GAAoB,MAApB;AACD;AAED;;;;AAIG;;;AACS,MAAR,QAAQ,GAAA;AACV,WAAO,KAAK,SAAZ;AACD;AAED;;;;AAIG;;;AACS,MAAR,QAAQ,CAAC,QAAD,EAAyB;AACnC,IAAA,OAAA,CAAA,aAAA,CAAc,QAAd;AAEA,SAAK,SAAL,GAAiB,QAAjB;AACD;AAED;;;;AAIG;;;AACe,MAAd,cAAc,GAAA;AAChB,WAAO,KAAK,KAAZ;AACD;AAED;;;;AAIG;;;AACH,EAAA,QAAQ,GAAA;AACN,WAAO,KAAK,KAAL,CAAW,KAAX,CAAiB,CAAjB,EAAoB,KAAK,MAAzB,CAAP;AACD;AAED;;;;AAIG;;;AACH,EAAA,QAAQ,CAAC,QAAD,EAA0B;AAChC,UAAM,WAAW,GAAG,OAAO,QAAP,KAAoB,QAApB,GAA+B,QAA/B,GAA0C,KAAK,SAAnE,CADgC,CAGhC;;AACA,IAAA,OAAA,CAAA,aAAA,CAAc,WAAd;AAEA,WAAO,KAAK,KAAL,CAAW,QAAX,CAAoB,WAApB,EAAiC,CAAjC,EAAoC,KAAK,MAAzC,CAAP;AACD;AAED;;AAEG;;;AACH,EAAA,OAAO,GAAA;AACL,SAAK,KAAL;AACA,WAAO,IAAP;AACD;AAED;;;;;;;AAOG;;;AACK,EAAA,aAAa,CACnB,KADmB,EAEnB,QAFmB,EAGnB,IAHmB,EAInB,QAJmB,EAIM;AAEzB,QAAI,SAAS,GAAG,KAAK,YAArB;AACA,QAAI,WAAW,GAAG,KAAK,SAAvB,CAHyB,CAKzB;;AACA,QAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,MAAA,SAAS,GAAG,IAAZ,CAD4B,CAE5B;AACD,KAHD,MAGO,IAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AACnC,MAAA,OAAA,CAAA,aAAA,CAAc,IAAd;AACA,MAAA,WAAW,GAAG,IAAd;AACD,KAZwB,CAczB;;;AACA,QAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,MAAA,OAAA,CAAA,aAAA,CAAc,QAAd;AACA,MAAA,WAAW,GAAG,QAAd;AACD,KAlBwB,CAoBzB;;;AACA,UAAM,UAAU,GAAG,MAAM,CAAC,UAAP,CAAkB,KAAlB,EAAyB,WAAzB,CAAnB,CArByB,CAuBzB;;AACA,QAAI,QAAJ,EAAc;AACZ,WAAK,gBAAL,CAAsB,UAAtB,EAAkC,SAAlC;AACD,KAFD,MAEO;AACL,WAAK,gBAAL,CAAsB,UAAtB,EAAkC,SAAlC;AACD,KA5BwB,CA8BzB;;;AACA,SAAK,KAAL,CAAW,KAAX,CAAiB,KAAjB,EAAwB,SAAxB,EAAmC,UAAnC,EAA+C,WAA/C,EA/ByB,CAiCzB;;;AACA,QAAI,QAAJ,EAAc;AACZ,WAAK,YAAL,IAAqB,UAArB;AACD,KAFD,MAEO;AACL;AACA,UAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,aAAK,YAAL,GAAoB,IAAI,CAAC,GAAL,CAAS,KAAK,YAAd,EAA4B,SAAS,GAAG,UAAxC,CAApB;AACD,OAFD,MAEO;AACL;AACA,aAAK,YAAL,IAAqB,UAArB;AACD;AACF;;AAED,WAAO,IAAP;AACD;AAED;;;;;AAKG;;;AACK,EAAA,aAAa,CAAC,KAAD,EAAgB,QAAhB,EAAmC,MAAnC,EAAkD;AACrE,UAAM,SAAS,GAAG,OAAO,MAAP,KAAkB,QAAlB,GAA6B,MAA7B,GAAsC,KAAK,YAA7D,CADqE,CAGrE;;AACA,QAAI,QAAJ,EAAc;AACZ,WAAK,gBAAL,CAAsB,KAAK,CAAC,MAA5B,EAAoC,SAApC;AACD,KAFD,MAEO;AACL,WAAK,gBAAL,CAAsB,KAAK,CAAC,MAA5B,EAAoC,SAApC;AACD,KARoE,CAUrE;;;AACA,IAAA,KAAK,CAAC,IAAN,CAAW,KAAK,KAAhB,EAAuB,SAAvB,EAXqE,CAarE;;AACA,QAAI,QAAJ,EAAc;AACZ,WAAK,YAAL,IAAqB,KAAK,CAAC,MAA3B;AACD,KAFD,MAEO;AACL;AACA,UAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,aAAK,YAAL,GAAoB,IAAI,CAAC,GAAL,CAAS,KAAK,YAAd,EAA4B,SAAS,GAAG,KAAK,CAAC,MAA9C,CAApB;AACD,OAFD,MAEO;AACL;AACA,aAAK,YAAL,IAAqB,KAAK,CAAC,MAA3B;AACD;AACF;;AAED,WAAO,IAAP;AACD;AAED;;;;;AAKG;;;AACK,EAAA,cAAc,CAAC,MAAD,EAAiB,MAAjB,EAAgC;AACpD;AACA,QAAI,SAAS,GAAG,KAAK,WAArB,CAFoD,CAIpD;;AACA,QAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;AACjC;AACA,MAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB,EAFiC,CAIjC;;AACA,MAAA,SAAS,GAAG,MAAZ;AACD,KAXmD,CAapD;;;AACA,QAAI,SAAS,GAAG,CAAZ,IAAiB,SAAS,GAAG,MAAZ,GAAqB,KAAK,MAA/C,EAAuD;AACrD,YAAM,IAAI,KAAJ,CAAU,OAAA,CAAA,MAAA,CAAO,0BAAjB,CAAN;AACD;AACF;AAED;;;;;AAKG;;;AACK,EAAA,gBAAgB,CAAC,UAAD,EAAqB,MAArB,EAAmC;AACzD;AACA,IAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB,EAFyD,CAIzD;;AACA,SAAK,eAAL,CAAqB,KAAK,MAAL,GAAc,UAAnC,EALyD,CAOzD;;;AACA,QAAI,MAAM,GAAG,KAAK,MAAlB,EAA0B;AACxB,WAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,KAArB,EAA4B,MAAM,GAAG,UAArC,EAAiD,MAAjD,EAAyD,KAAK,KAAL,CAAW,MAApE;AACD,KAVwD,CAYzD;;;AACA,QAAI,MAAM,GAAG,UAAT,GAAsB,KAAK,MAA/B,EAAuC;AACrC,WAAK,MAAL,GAAc,MAAM,GAAG,UAAvB;AACD,KAFD,MAEO;AACL,WAAK,MAAL,IAAe,UAAf;AACD;AACF;AAED;;;;;AAKG;;;AACK,EAAA,gBAAgB,CAAC,UAAD,EAAqB,MAArB,EAAoC;AAC1D,UAAM,SAAS,GAAG,OAAO,MAAP,KAAkB,QAAlB,GAA6B,MAA7B,GAAsC,KAAK,YAA7D,CAD0D,CAG1D;;AACA,SAAK,eAAL,CAAqB,SAAS,GAAG,UAAjC,EAJ0D,CAM1D;;;AACA,QAAI,SAAS,GAAG,UAAZ,GAAyB,KAAK,MAAlC,EAA0C;AACxC,WAAK,MAAL,GAAc,SAAS,GAAG,UAA1B;AACD;AACF;AAED;;;;AAIG;;;AACK,EAAA,eAAe,CAAC,SAAD,EAAkB;AACvC,UAAM,SAAS,GAAG,KAAK,KAAL,CAAW,MAA7B;;AAEA,QAAI,SAAS,GAAG,SAAhB,EAA2B;AACzB,UAAI,IAAI,GAAG,KAAK,KAAhB;AACA,UAAI,SAAS,GAAI,SAAS,GAAG,CAAb,GAAkB,CAAlB,GAAsB,CAAtC;;AACA,UAAI,SAAS,GAAG,SAAhB,EAA2B;AACzB,QAAA,SAAS,GAAG,SAAZ;AACD;;AACD,WAAK,KAAL,GAAa,MAAM,CAAC,WAAP,CAAmB,SAAnB,CAAb;AAEA,MAAA,IAAI,CAAC,IAAL,CAAU,KAAK,KAAf,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,SAA5B;AACD;AACF;AAED;;;;;;;;;;AAUG;;;AACK,EAAA,gBAAgB,CAAI,IAAJ,EAAiC,QAAjC,EAAmD,MAAnD,EAAkE;AACxF,SAAK,cAAL,CAAoB,QAApB,EAA8B,MAA9B,EADwF,CAGxF;;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,IAAL,CAAU,KAAK,KAAf,EAAsB,OAAO,MAAP,KAAkB,QAAlB,GAA6B,MAA7B,GAAsC,KAAK,WAAjE,CAAd,CAJwF,CAMxF;;AACA,QAAI,OAAO,MAAP,KAAkB,WAAtB,EAAmC;AACjC,WAAK,WAAL,IAAoB,QAApB;AACD;;AAED,WAAO,KAAP;AACD;AAED;;;;;;;;;;;AAWG;;;AACK,EAAA,kBAAkB,CACxB,IADwB,EAExB,QAFwB,EAGxB,KAHwB,EAIxB,MAJwB,EAIV;AAEd;AACA,IAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB,EAHc,CAKd;;AACA,SAAK,gBAAL,CAAsB,QAAtB,EAAgC,MAAhC,EANc,CAQd;;AACA,IAAA,IAAI,CAAC,IAAL,CAAU,KAAK,KAAf,EAAsB,KAAtB,EAA6B,MAA7B,EATc,CAWd;;AACA,SAAK,YAAL,IAAqB,QAArB;AACA,WAAO,IAAP;AACD;AAED;;;;;;;;;;;AAWG;;;AACK,EAAA,iBAAiB,CACvB,IADuB,EAEvB,QAFuB,EAGvB,KAHuB,EAIvB,MAJuB,EAIR;AAEf;AACA,QAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B;AACA,UAAI,MAAM,GAAG,CAAb,EAAgB;AACd,cAAM,IAAI,KAAJ,CAAU,OAAA,CAAA,MAAA,CAAO,2BAAjB,CAAN;AACD;;AAED,MAAA,OAAA,CAAA,gBAAA,CAAiB,MAAjB;AACD,KAVc,CAYf;;;AACA,UAAM,SAAS,GAAG,OAAO,MAAP,KAAkB,QAAlB,GAA6B,MAA7B,GAAsC,KAAK,YAA7D,CAbe,CAef;;AACA,SAAK,gBAAL,CAAsB,QAAtB,EAAgC,SAAhC;;AAEA,IAAA,IAAI,CAAC,IAAL,CAAU,KAAK,KAAf,EAAsB,KAAtB,EAA6B,SAA7B,EAlBe,CAoBf;;AACA,QAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,WAAK,YAAL,GAAoB,IAAI,CAAC,GAAL,CAAS,KAAK,YAAd,EAA4B,SAAS,GAAG,QAAxC,CAApB;AACD,KAFD,MAEO;AACL;AACA,WAAK,YAAL,IAAqB,QAArB;AACD;;AAED,WAAO,IAAP;AACD;;AA72Cc;;AAg3CY,OAAA,CAAA,WAAA,GAAA,WAAA","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst utils_1 = require(\"./utils\");\r\n// The default Buffer size if one is not provided.\r\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\r\n// The default string encoding to use for reading/writing strings.\r\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\r\nclass SmartBuffer {\r\n    /**\r\n     * Creates a new SmartBuffer instance.\r\n     *\r\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\r\n     */\r\n    constructor(options) {\r\n        this.length = 0;\r\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\r\n        this._writeOffset = 0;\r\n        this._readOffset = 0;\r\n        if (SmartBuffer.isSmartBufferOptions(options)) {\r\n            // Checks for encoding\r\n            if (options.encoding) {\r\n                utils_1.checkEncoding(options.encoding);\r\n                this._encoding = options.encoding;\r\n            }\r\n            // Checks for initial size length\r\n            if (options.size) {\r\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\r\n                    this._buff = Buffer.allocUnsafe(options.size);\r\n                }\r\n                else {\r\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\r\n                }\r\n                // Check for initial Buffer\r\n            }\r\n            else if (options.buff) {\r\n                if (options.buff instanceof Buffer) {\r\n                    this._buff = options.buff;\r\n                    this.length = options.buff.length;\r\n                }\r\n                else {\r\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\r\n                }\r\n            }\r\n            else {\r\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\r\n            }\r\n        }\r\n        else {\r\n            // If something was passed but it's not a SmartBufferOptions object\r\n            if (typeof options !== 'undefined') {\r\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\r\n            }\r\n            // Otherwise default to sane options\r\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\r\n        }\r\n    }\r\n    /**\r\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\r\n     *\r\n     * @param size { Number } The size of the internal Buffer.\r\n     * @param encoding { String } The BufferEncoding to use for strings.\r\n     *\r\n     * @return { SmartBuffer }\r\n     */\r\n    static fromSize(size, encoding) {\r\n        return new this({\r\n            size: size,\r\n            encoding: encoding\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\r\n     *\r\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\r\n     * @param encoding { String } The BufferEncoding to use for strings.\r\n     *\r\n     * @return { SmartBuffer }\r\n     */\r\n    static fromBuffer(buff, encoding) {\r\n        return new this({\r\n            buff: buff,\r\n            encoding: encoding\r\n        });\r\n    }\r\n    /**\r\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\r\n     *\r\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\r\n     */\r\n    static fromOptions(options) {\r\n        return new this(options);\r\n    }\r\n    /**\r\n     * Type checking function that determines if an object is a SmartBufferOptions object.\r\n     */\r\n    static isSmartBufferOptions(options) {\r\n        const castOptions = options;\r\n        return (castOptions &&\r\n            (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined));\r\n    }\r\n    // Signed integers\r\n    /**\r\n     * Reads an Int8 value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readInt8(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\r\n    }\r\n    /**\r\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readInt16BE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\r\n    }\r\n    /**\r\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readInt16LE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\r\n    }\r\n    /**\r\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readInt32BE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\r\n    }\r\n    /**\r\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readInt32LE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\r\n    }\r\n    /**\r\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { BigInt }\r\n     */\r\n    readBigInt64BE(offset) {\r\n        utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\r\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\r\n    }\r\n    /**\r\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { BigInt }\r\n     */\r\n    readBigInt64LE(offset) {\r\n        utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\r\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\r\n    }\r\n    /**\r\n     * Writes an Int8 value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeInt8(value, offset) {\r\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\r\n        return this;\r\n    }\r\n    /**\r\n     * Inserts an Int8 value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertInt8(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\r\n    }\r\n    /**\r\n     * Writes an Int16BE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeInt16BE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\r\n    }\r\n    /**\r\n     * Inserts an Int16BE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertInt16BE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\r\n    }\r\n    /**\r\n     * Writes an Int16LE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeInt16LE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\r\n    }\r\n    /**\r\n     * Inserts an Int16LE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertInt16LE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\r\n    }\r\n    /**\r\n     * Writes an Int32BE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeInt32BE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Inserts an Int32BE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertInt32BE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Writes an Int32LE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeInt32LE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Inserts an Int32LE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertInt32LE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { BigInt } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeBigInt64BE(value, offset) {\r\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\r\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\r\n    }\r\n    /**\r\n     * Inserts a BigInt64BE value at the given offset value.\r\n     *\r\n     * @param value { BigInt } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertBigInt64BE(value, offset) {\r\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\r\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\r\n    }\r\n    /**\r\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { BigInt } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeBigInt64LE(value, offset) {\r\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\r\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\r\n    }\r\n    /**\r\n     * Inserts a Int64LE value at the given offset value.\r\n     *\r\n     * @param value { BigInt } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertBigInt64LE(value, offset) {\r\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\r\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\r\n    }\r\n    // Unsigned Integers\r\n    /**\r\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readUInt8(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\r\n    }\r\n    /**\r\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readUInt16BE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\r\n    }\r\n    /**\r\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readUInt16LE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\r\n    }\r\n    /**\r\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readUInt32BE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\r\n    }\r\n    /**\r\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readUInt32LE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\r\n    }\r\n    /**\r\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { BigInt }\r\n     */\r\n    readBigUInt64BE(offset) {\r\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\r\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\r\n    }\r\n    /**\r\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { BigInt }\r\n     */\r\n    readBigUInt64LE(offset) {\r\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\r\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\r\n    }\r\n    /**\r\n     * Writes an UInt8 value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeUInt8(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\r\n    }\r\n    /**\r\n     * Inserts an UInt8 value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertUInt8(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\r\n    }\r\n    /**\r\n     * Writes an UInt16BE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeUInt16BE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\r\n    }\r\n    /**\r\n     * Inserts an UInt16BE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertUInt16BE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\r\n    }\r\n    /**\r\n     * Writes an UInt16LE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeUInt16LE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\r\n    }\r\n    /**\r\n     * Inserts an UInt16LE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertUInt16LE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\r\n    }\r\n    /**\r\n     * Writes an UInt32BE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeUInt32BE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Inserts an UInt32BE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertUInt32BE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Writes an UInt32LE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeUInt32LE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Inserts an UInt32LE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertUInt32LE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeBigUInt64BE(value, offset) {\r\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\r\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\r\n    }\r\n    /**\r\n     * Inserts a BigUInt64BE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertBigUInt64BE(value, offset) {\r\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\r\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\r\n    }\r\n    /**\r\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeBigUInt64LE(value, offset) {\r\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\r\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\r\n    }\r\n    /**\r\n     * Inserts a BigUInt64LE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertBigUInt64LE(value, offset) {\r\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\r\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\r\n    }\r\n    // Floating Point\r\n    /**\r\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readFloatBE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\r\n    }\r\n    /**\r\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readFloatLE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\r\n    }\r\n    /**\r\n     * Writes a FloatBE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeFloatBE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Inserts a FloatBE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertFloatBE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Writes a FloatLE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeFloatLE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\r\n    }\r\n    /**\r\n     * Inserts a FloatLE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertFloatLE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\r\n    }\r\n    // Double Floating Point\r\n    /**\r\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readDoubleBE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\r\n    }\r\n    /**\r\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\r\n     *\r\n     * @param offset { Number } The offset to read data from (optional)\r\n     * @return { Number }\r\n     */\r\n    readDoubleLE(offset) {\r\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\r\n    }\r\n    /**\r\n     * Writes a DoubleBE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeDoubleBE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\r\n    }\r\n    /**\r\n     * Inserts a DoubleBE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertDoubleBE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\r\n    }\r\n    /**\r\n     * Writes a DoubleLE value to the current write position (or at optional offset).\r\n     *\r\n     * @param value { Number } The value to write.\r\n     * @param offset { Number } The offset to write the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    writeDoubleLE(value, offset) {\r\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\r\n    }\r\n    /**\r\n     * Inserts a DoubleLE value at the given offset value.\r\n     *\r\n     * @param value { Number } The value to insert.\r\n     * @param offset { Number } The offset to insert the value at.\r\n     *\r\n     * @return this\r\n     */\r\n    insertDoubleLE(value, offset) {\r\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\r\n    }\r\n    // Strings\r\n    /**\r\n     * Reads a String from the current read position.\r\n     *\r\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\r\n     *             the string (Defaults to instance level encoding).\r\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\r\n     *\r\n     * @return { String }\r\n     */\r\n    readString(arg1, encoding) {\r\n        let lengthVal;\r\n        // Length provided\r\n        if (typeof arg1 === 'number') {\r\n            utils_1.checkLengthValue(arg1);\r\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\r\n        }\r\n        else {\r\n            encoding = arg1;\r\n            lengthVal = this.length - this._readOffset;\r\n        }\r\n        // Check encoding\r\n        if (typeof encoding !== 'undefined') {\r\n            utils_1.checkEncoding(encoding);\r\n        }\r\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\r\n        this._readOffset += lengthVal;\r\n        return value;\r\n    }\r\n    /**\r\n     * Inserts a String\r\n     *\r\n     * @param value { String } The String value to insert.\r\n     * @param offset { Number } The offset to insert the string at.\r\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n     *\r\n     * @return this\r\n     */\r\n    insertString(value, offset, encoding) {\r\n        utils_1.checkOffsetValue(offset);\r\n        return this._handleString(value, true, offset, encoding);\r\n    }\r\n    /**\r\n     * Writes a String\r\n     *\r\n     * @param value { String } The String value to write.\r\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\r\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n     *\r\n     * @return this\r\n     */\r\n    writeString(value, arg2, encoding) {\r\n        return this._handleString(value, false, arg2, encoding);\r\n    }\r\n    /**\r\n     * Reads a null-terminated String from the current read position.\r\n     *\r\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\r\n     *\r\n     * @return { String }\r\n     */\r\n    readStringNT(encoding) {\r\n        if (typeof encoding !== 'undefined') {\r\n            utils_1.checkEncoding(encoding);\r\n        }\r\n        // Set null character position to the end SmartBuffer instance.\r\n        let nullPos = this.length;\r\n        // Find next null character (if one is not found, default from above is used)\r\n        for (let i = this._readOffset; i < this.length; i++) {\r\n            if (this._buff[i] === 0x00) {\r\n                nullPos = i;\r\n                break;\r\n            }\r\n        }\r\n        // Read string value\r\n        const value = this._buff.slice(this._readOffset, nullPos);\r\n        // Increment internal Buffer read offset\r\n        this._readOffset = nullPos + 1;\r\n        return value.toString(encoding || this._encoding);\r\n    }\r\n    /**\r\n     * Inserts a null-terminated String.\r\n     *\r\n     * @param value { String } The String value to write.\r\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\r\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n     *\r\n     * @return this\r\n     */\r\n    insertStringNT(value, offset, encoding) {\r\n        utils_1.checkOffsetValue(offset);\r\n        // Write Values\r\n        this.insertString(value, offset, encoding);\r\n        this.insertUInt8(0x00, offset + value.length);\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a null-terminated String.\r\n     *\r\n     * @param value { String } The String value to write.\r\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\r\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n     *\r\n     * @return this\r\n     */\r\n    writeStringNT(value, arg2, encoding) {\r\n        // Write Values\r\n        this.writeString(value, arg2, encoding);\r\n        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\r\n        return this;\r\n    }\r\n    // Buffers\r\n    /**\r\n     * Reads a Buffer from the internal read position.\r\n     *\r\n     * @param length { Number } The length of data to read as a Buffer.\r\n     *\r\n     * @return { Buffer }\r\n     */\r\n    readBuffer(length) {\r\n        if (typeof length !== 'undefined') {\r\n            utils_1.checkLengthValue(length);\r\n        }\r\n        const lengthVal = typeof length === 'number' ? length : this.length;\r\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\r\n        // Read buffer value\r\n        const value = this._buff.slice(this._readOffset, endPoint);\r\n        // Increment internal Buffer read offset\r\n        this._readOffset = endPoint;\r\n        return value;\r\n    }\r\n    /**\r\n     * Writes a Buffer to the current write position.\r\n     *\r\n     * @param value { Buffer } The Buffer to write.\r\n     * @param offset { Number } The offset to write the Buffer to.\r\n     *\r\n     * @return this\r\n     */\r\n    insertBuffer(value, offset) {\r\n        utils_1.checkOffsetValue(offset);\r\n        return this._handleBuffer(value, true, offset);\r\n    }\r\n    /**\r\n     * Writes a Buffer to the current write position.\r\n     *\r\n     * @param value { Buffer } The Buffer to write.\r\n     * @param offset { Number } The offset to write the Buffer to.\r\n     *\r\n     * @return this\r\n     */\r\n    writeBuffer(value, offset) {\r\n        return this._handleBuffer(value, false, offset);\r\n    }\r\n    /**\r\n     * Reads a null-terminated Buffer from the current read poisiton.\r\n     *\r\n     * @return { Buffer }\r\n     */\r\n    readBufferNT() {\r\n        // Set null character position to the end SmartBuffer instance.\r\n        let nullPos = this.length;\r\n        // Find next null character (if one is not found, default from above is used)\r\n        for (let i = this._readOffset; i < this.length; i++) {\r\n            if (this._buff[i] === 0x00) {\r\n                nullPos = i;\r\n                break;\r\n            }\r\n        }\r\n        // Read value\r\n        const value = this._buff.slice(this._readOffset, nullPos);\r\n        // Increment internal Buffer read offset\r\n        this._readOffset = nullPos + 1;\r\n        return value;\r\n    }\r\n    /**\r\n     * Inserts a null-terminated Buffer.\r\n     *\r\n     * @param value { Buffer } The Buffer to write.\r\n     * @param offset { Number } The offset to write the Buffer to.\r\n     *\r\n     * @return this\r\n     */\r\n    insertBufferNT(value, offset) {\r\n        utils_1.checkOffsetValue(offset);\r\n        // Write Values\r\n        this.insertBuffer(value, offset);\r\n        this.insertUInt8(0x00, offset + value.length);\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a null-terminated Buffer.\r\n     *\r\n     * @param value { Buffer } The Buffer to write.\r\n     * @param offset { Number } The offset to write the Buffer to.\r\n     *\r\n     * @return this\r\n     */\r\n    writeBufferNT(value, offset) {\r\n        // Checks for valid numberic value;\r\n        if (typeof offset !== 'undefined') {\r\n            utils_1.checkOffsetValue(offset);\r\n        }\r\n        // Write Values\r\n        this.writeBuffer(value, offset);\r\n        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\r\n        return this;\r\n    }\r\n    /**\r\n     * Clears the SmartBuffer instance to its original empty state.\r\n     */\r\n    clear() {\r\n        this._writeOffset = 0;\r\n        this._readOffset = 0;\r\n        this.length = 0;\r\n        return this;\r\n    }\r\n    /**\r\n     * Gets the remaining data left to be read from the SmartBuffer instance.\r\n     *\r\n     * @return { Number }\r\n     */\r\n    remaining() {\r\n        return this.length - this._readOffset;\r\n    }\r\n    /**\r\n     * Gets the current read offset value of the SmartBuffer instance.\r\n     *\r\n     * @return { Number }\r\n     */\r\n    get readOffset() {\r\n        return this._readOffset;\r\n    }\r\n    /**\r\n     * Sets the read offset value of the SmartBuffer instance.\r\n     *\r\n     * @param offset { Number } - The offset value to set.\r\n     */\r\n    set readOffset(offset) {\r\n        utils_1.checkOffsetValue(offset);\r\n        // Check for bounds.\r\n        utils_1.checkTargetOffset(offset, this);\r\n        this._readOffset = offset;\r\n    }\r\n    /**\r\n     * Gets the current write offset value of the SmartBuffer instance.\r\n     *\r\n     * @return { Number }\r\n     */\r\n    get writeOffset() {\r\n        return this._writeOffset;\r\n    }\r\n    /**\r\n     * Sets the write offset value of the SmartBuffer instance.\r\n     *\r\n     * @param offset { Number } - The offset value to set.\r\n     */\r\n    set writeOffset(offset) {\r\n        utils_1.checkOffsetValue(offset);\r\n        // Check for bounds.\r\n        utils_1.checkTargetOffset(offset, this);\r\n        this._writeOffset = offset;\r\n    }\r\n    /**\r\n     * Gets the currently set string encoding of the SmartBuffer instance.\r\n     *\r\n     * @return { BufferEncoding } The string Buffer encoding currently set.\r\n     */\r\n    get encoding() {\r\n        return this._encoding;\r\n    }\r\n    /**\r\n     * Sets the string encoding of the SmartBuffer instance.\r\n     *\r\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\r\n     */\r\n    set encoding(encoding) {\r\n        utils_1.checkEncoding(encoding);\r\n        this._encoding = encoding;\r\n    }\r\n    /**\r\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\r\n     *\r\n     * @return { Buffer } The Buffer value.\r\n     */\r\n    get internalBuffer() {\r\n        return this._buff;\r\n    }\r\n    /**\r\n     * Gets the value of the internal managed Buffer (Includes managed data only)\r\n     *\r\n     * @param { Buffer }\r\n     */\r\n    toBuffer() {\r\n        return this._buff.slice(0, this.length);\r\n    }\r\n    /**\r\n     * Gets the String value of the internal managed Buffer\r\n     *\r\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\r\n     */\r\n    toString(encoding) {\r\n        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;\r\n        // Check for invalid encoding.\r\n        utils_1.checkEncoding(encodingVal);\r\n        return this._buff.toString(encodingVal, 0, this.length);\r\n    }\r\n    /**\r\n     * Destroys the SmartBuffer instance.\r\n     */\r\n    destroy() {\r\n        this.clear();\r\n        return this;\r\n    }\r\n    /**\r\n     * Handles inserting and writing strings.\r\n     *\r\n     * @param value { String } The String value to insert.\r\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\r\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\r\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\r\n     */\r\n    _handleString(value, isInsert, arg3, encoding) {\r\n        let offsetVal = this._writeOffset;\r\n        let encodingVal = this._encoding;\r\n        // Check for offset\r\n        if (typeof arg3 === 'number') {\r\n            offsetVal = arg3;\r\n            // Check for encoding\r\n        }\r\n        else if (typeof arg3 === 'string') {\r\n            utils_1.checkEncoding(arg3);\r\n            encodingVal = arg3;\r\n        }\r\n        // Check for encoding (third param)\r\n        if (typeof encoding === 'string') {\r\n            utils_1.checkEncoding(encoding);\r\n            encodingVal = encoding;\r\n        }\r\n        // Calculate bytelength of string.\r\n        const byteLength = Buffer.byteLength(value, encodingVal);\r\n        // Ensure there is enough internal Buffer capacity.\r\n        if (isInsert) {\r\n            this.ensureInsertable(byteLength, offsetVal);\r\n        }\r\n        else {\r\n            this._ensureWriteable(byteLength, offsetVal);\r\n        }\r\n        // Write value\r\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\r\n        // Increment internal Buffer write offset;\r\n        if (isInsert) {\r\n            this._writeOffset += byteLength;\r\n        }\r\n        else {\r\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\r\n            if (typeof arg3 === 'number') {\r\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\r\n            }\r\n            else {\r\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\r\n                this._writeOffset += byteLength;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Handles writing or insert of a Buffer.\r\n     *\r\n     * @param value { Buffer } The Buffer to write.\r\n     * @param offset { Number } The offset to write the Buffer to.\r\n     */\r\n    _handleBuffer(value, isInsert, offset) {\r\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\r\n        // Ensure there is enough internal Buffer capacity.\r\n        if (isInsert) {\r\n            this.ensureInsertable(value.length, offsetVal);\r\n        }\r\n        else {\r\n            this._ensureWriteable(value.length, offsetVal);\r\n        }\r\n        // Write buffer value\r\n        value.copy(this._buff, offsetVal);\r\n        // Increment internal Buffer write offset;\r\n        if (isInsert) {\r\n            this._writeOffset += value.length;\r\n        }\r\n        else {\r\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\r\n            if (typeof offset === 'number') {\r\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\r\n            }\r\n            else {\r\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\r\n                this._writeOffset += value.length;\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Ensures that the internal Buffer is large enough to read data.\r\n     *\r\n     * @param length { Number } The length of the data that needs to be read.\r\n     * @param offset { Number } The offset of the data that needs to be read.\r\n     */\r\n    ensureReadable(length, offset) {\r\n        // Offset value defaults to managed read offset.\r\n        let offsetVal = this._readOffset;\r\n        // If an offset was provided, use it.\r\n        if (typeof offset !== 'undefined') {\r\n            // Checks for valid numberic value;\r\n            utils_1.checkOffsetValue(offset);\r\n            // Overide with custom offset.\r\n            offsetVal = offset;\r\n        }\r\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\r\n        if (offsetVal < 0 || offsetVal + length > this.length) {\r\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\r\n        }\r\n    }\r\n    /**\r\n     * Ensures that the internal Buffer is large enough to insert data.\r\n     *\r\n     * @param dataLength { Number } The length of the data that needs to be written.\r\n     * @param offset { Number } The offset of the data to be written.\r\n     */\r\n    ensureInsertable(dataLength, offset) {\r\n        // Checks for valid numberic value;\r\n        utils_1.checkOffsetValue(offset);\r\n        // Ensure there is enough internal Buffer capacity.\r\n        this._ensureCapacity(this.length + dataLength);\r\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\r\n        if (offset < this.length) {\r\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\r\n        }\r\n        // Adjust tracked smart buffer length\r\n        if (offset + dataLength > this.length) {\r\n            this.length = offset + dataLength;\r\n        }\r\n        else {\r\n            this.length += dataLength;\r\n        }\r\n    }\r\n    /**\r\n     * Ensures that the internal Buffer is large enough to write data.\r\n     *\r\n     * @param dataLength { Number } The length of the data that needs to be written.\r\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\r\n     */\r\n    _ensureWriteable(dataLength, offset) {\r\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\r\n        // Ensure enough capacity to write data.\r\n        this._ensureCapacity(offsetVal + dataLength);\r\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\r\n        if (offsetVal + dataLength > this.length) {\r\n            this.length = offsetVal + dataLength;\r\n        }\r\n    }\r\n    /**\r\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\r\n     *\r\n     * @param minLength { Number } The minimum length of the data needs to be written.\r\n     */\r\n    _ensureCapacity(minLength) {\r\n        const oldLength = this._buff.length;\r\n        if (minLength > oldLength) {\r\n            let data = this._buff;\r\n            let newLength = (oldLength * 3) / 2 + 1;\r\n            if (newLength < minLength) {\r\n                newLength = minLength;\r\n            }\r\n            this._buff = Buffer.allocUnsafe(newLength);\r\n            data.copy(this._buff, 0, 0, oldLength);\r\n        }\r\n    }\r\n    /**\r\n     * Reads a numeric number value using the provided function.\r\n     *\r\n     * @typeparam T { number | bigint } The type of the value to be read\r\n     *\r\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\r\n     * @param byteSize { Number } The number of bytes read.\r\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\r\n     *\r\n     * @returns { T } the number value\r\n     */\r\n    _readNumberValue(func, byteSize, offset) {\r\n        this.ensureReadable(byteSize, offset);\r\n        // Call Buffer.readXXXX();\r\n        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);\r\n        // Adjust internal read offset if an optional read offset was not provided.\r\n        if (typeof offset === 'undefined') {\r\n            this._readOffset += byteSize;\r\n        }\r\n        return value;\r\n    }\r\n    /**\r\n     * Inserts a numeric number value based on the given offset and value.\r\n     *\r\n     * @typeparam T { number | bigint } The type of the value to be written\r\n     *\r\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\r\n     * @param byteSize { Number } The number of bytes written.\r\n     * @param value { T } The number value to write.\r\n     * @param offset { Number } the offset to write the number at (REQUIRED).\r\n     *\r\n     * @returns SmartBuffer this buffer\r\n     */\r\n    _insertNumberValue(func, byteSize, value, offset) {\r\n        // Check for invalid offset values.\r\n        utils_1.checkOffsetValue(offset);\r\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\r\n        this.ensureInsertable(byteSize, offset);\r\n        // Call buffer.writeXXXX();\r\n        func.call(this._buff, value, offset);\r\n        // Adjusts internally managed write offset.\r\n        this._writeOffset += byteSize;\r\n        return this;\r\n    }\r\n    /**\r\n     * Writes a numeric number value based on the given offset and value.\r\n     *\r\n     * @typeparam T { number | bigint } The type of the value to be written\r\n     *\r\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\r\n     * @param byteSize { Number } The number of bytes written.\r\n     * @param value { T } The number value to write.\r\n     * @param offset { Number } the offset to write the number at (REQUIRED).\r\n     *\r\n     * @returns SmartBuffer this buffer\r\n     */\r\n    _writeNumberValue(func, byteSize, value, offset) {\r\n        // If an offset was provided, validate it.\r\n        if (typeof offset === 'number') {\r\n            // Check if we're writing beyond the bounds of the managed data.\r\n            if (offset < 0) {\r\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\r\n            }\r\n            utils_1.checkOffsetValue(offset);\r\n        }\r\n        // Default to writeOffset if no offset value was given.\r\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\r\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\r\n        this._ensureWriteable(byteSize, offsetVal);\r\n        func.call(this._buff, value, offsetVal);\r\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\r\n        if (typeof offset === 'number') {\r\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\r\n        }\r\n        else {\r\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\r\n            this._writeOffset += byteSize;\r\n        }\r\n        return this;\r\n    }\r\n}\r\nexports.SmartBuffer = SmartBuffer;\r\n//# sourceMappingURL=smartbuffer.js.map"]},"metadata":{},"sourceType":"script"}