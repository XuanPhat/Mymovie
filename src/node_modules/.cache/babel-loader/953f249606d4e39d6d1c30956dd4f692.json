{"ast":null,"code":"'use strict';\n/**\r\n * headers.js\r\n *\r\n * Headers class offers convenient helpers\r\n */\n\nconst common = require('./common.js');\n\nconst checkInvalidHeaderChar = common.checkInvalidHeaderChar;\nconst checkIsHttpToken = common.checkIsHttpToken;\n\nfunction sanitizeName(name) {\n  name += '';\n\n  if (!checkIsHttpToken(name)) {\n    throw new TypeError(`${name} is not a legal HTTP header name`);\n  }\n\n  return name.toLowerCase();\n}\n\nfunction sanitizeValue(value) {\n  value += '';\n\n  if (checkInvalidHeaderChar(value)) {\n    throw new TypeError(`${value} is not a legal HTTP header value`);\n  }\n\n  return value;\n}\n\nconst MAP = Symbol('map');\n\nclass Headers {\n  /**\r\n   * Headers class\r\n   *\r\n   * @param   Object  headers  Response headers\r\n   * @return  Void\r\n   */\n  constructor(init) {\n    this[MAP] = Object.create(null);\n\n    if (init instanceof Headers) {\n      const rawHeaders = init.raw();\n      const headerNames = Object.keys(rawHeaders);\n\n      for (const headerName of headerNames) {\n        for (const value of rawHeaders[headerName]) {\n          this.append(headerName, value);\n        }\n      }\n\n      return;\n    } // We don't worry about converting prop to ByteString here as append()\n    // will handle it.\n\n\n    if (init == null) {// no op\n    } else if (typeof init === 'object') {\n      const method = init[Symbol.iterator];\n\n      if (method != null) {\n        if (typeof method !== 'function') {\n          throw new TypeError('Header pairs must be iterable');\n        } // sequence<sequence<ByteString>>\n        // Note: per spec we have to first exhaust the lists then process them\n\n\n        const pairs = [];\n\n        for (const pair of init) {\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\n            throw new TypeError('Each header pair must be iterable');\n          }\n\n          pairs.push(Array.from(pair));\n        }\n\n        for (const pair of pairs) {\n          if (pair.length !== 2) {\n            throw new TypeError('Each header pair must be a name/value tuple');\n          }\n\n          this.append(pair[0], pair[1]);\n        }\n      } else {\n        // record<ByteString, ByteString>\n        for (const key of Object.keys(init)) {\n          const value = init[key];\n          this.append(key, value);\n        }\n      }\n    } else {\n      throw new TypeError('Provided initializer must be an object');\n    }\n\n    Object.defineProperty(this, Symbol.toStringTag, {\n      value: 'Headers',\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n  }\n  /**\r\n   * Return first header value given name\r\n   *\r\n   * @param   String  name  Header name\r\n   * @return  Mixed\r\n   */\n\n\n  get(name) {\n    const list = this[MAP][sanitizeName(name)];\n\n    if (!list) {\n      return null;\n    }\n\n    return list.join(', ');\n  }\n  /**\r\n   * Iterate over all headers\r\n   *\r\n   * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\r\n   * @param   Boolean   thisArg   `this` context for callback function\r\n   * @return  Void\r\n   */\n\n\n  forEach(callback, thisArg) {\n    let pairs = getHeaderPairs(this);\n    let i = 0;\n\n    while (i < pairs.length) {\n      const name = pairs[i][0];\n      const value = pairs[i][1];\n      callback.call(thisArg, value, name, this);\n      pairs = getHeaderPairs(this);\n      i++;\n    }\n  }\n  /**\r\n   * Overwrite header values given name\r\n   *\r\n   * @param   String  name   Header name\r\n   * @param   String  value  Header value\r\n   * @return  Void\r\n   */\n\n\n  set(name, value) {\n    this[MAP][sanitizeName(name)] = [sanitizeValue(value)];\n  }\n  /**\r\n   * Append a value onto existing header\r\n   *\r\n   * @param   String  name   Header name\r\n   * @param   String  value  Header value\r\n   * @return  Void\r\n   */\n\n\n  append(name, value) {\n    if (!this.has(name)) {\n      this.set(name, value);\n      return;\n    }\n\n    this[MAP][sanitizeName(name)].push(sanitizeValue(value));\n  }\n  /**\r\n   * Check for header name existence\r\n   *\r\n   * @param   String   name  Header name\r\n   * @return  Boolean\r\n   */\n\n\n  has(name) {\n    return !!this[MAP][sanitizeName(name)];\n  }\n  /**\r\n   * Delete all header values given name\r\n   *\r\n   * @param   String  name  Header name\r\n   * @return  Void\r\n   */\n\n\n  delete(name) {\n    delete this[MAP][sanitizeName(name)];\n  }\n\n  /**\r\n   * Return raw headers (non-spec api)\r\n   *\r\n   * @return  Object\r\n   */\n  raw() {\n    return this[MAP];\n  }\n  /**\r\n   * Get an iterator on keys.\r\n   *\r\n   * @return  Iterator\r\n   */\n\n\n  keys() {\n    return createHeadersIterator(this, 'key');\n  }\n  /**\r\n   * Get an iterator on values.\r\n   *\r\n   * @return  Iterator\r\n   */\n\n\n  values() {\n    return createHeadersIterator(this, 'value');\n  }\n  /**\r\n   * Get an iterator on entries.\r\n   *\r\n   * This is the default iterator of the Headers object.\r\n   *\r\n   * @return  Iterator\r\n   */\n\n\n  [Symbol.iterator]() {\n    return createHeadersIterator(this, 'key+value');\n  }\n\n}\n\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator];\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\n  value: 'HeadersPrototype',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\nfunction getHeaderPairs(headers, kind) {\n  const keys = Object.keys(headers[MAP]).sort();\n  return keys.map(kind === 'key' ? k => [k] : k => [k, headers.get(k)]);\n}\n\nconst INTERNAL = Symbol('internal');\n\nfunction createHeadersIterator(target, kind) {\n  const iterator = Object.create(HeadersIteratorPrototype);\n  iterator[INTERNAL] = {\n    target,\n    kind,\n    index: 0\n  };\n  return iterator;\n}\n\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\n  next() {\n    // istanbul ignore if\n    if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\n      throw new TypeError('Value of `this` is not a HeadersIterator');\n    }\n\n    const target = this[INTERNAL].target;\n    const kind = this[INTERNAL].kind;\n    const index = this[INTERNAL].index;\n    const values = getHeaderPairs(target, kind);\n    const len = values.length;\n\n    if (index >= len) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n\n    const pair = values[index];\n    this[INTERNAL].index = index + 1;\n    let result;\n\n    if (kind === 'key') {\n      result = pair[0];\n    } else if (kind === 'value') {\n      result = pair[1];\n    } else {\n      result = pair;\n    }\n\n    return {\n      value: result,\n      done: false\n    };\n  }\n\n}, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\n  value: 'HeadersIterator',\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nmodule.exports = Headers;","map":{"version":3,"sources":["D:/node_modules/npm/node_modules/node-fetch-npm/src/headers.js"],"names":["common","require","checkInvalidHeaderChar","checkIsHttpToken","sanitizeName","name","TypeError","toLowerCase","sanitizeValue","value","MAP","Symbol","Headers","constructor","init","Object","create","rawHeaders","raw","headerNames","keys","headerName","append","method","iterator","pairs","pair","push","Array","from","length","key","defineProperty","toStringTag","writable","enumerable","configurable","get","list","join","forEach","callback","thisArg","getHeaderPairs","i","call","set","has","delete","createHeadersIterator","values","prototype","entries","headers","kind","sort","map","k","INTERNAL","target","HeadersIteratorPrototype","index","setPrototypeOf","next","getPrototypeOf","len","undefined","done","result","module","exports"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\n/**\r\n * headers.js\r\n *\r\n * Headers class offers convenient helpers\r\n */\r\n\r\nconst common = require('./common.js')\r\nconst checkInvalidHeaderChar = common.checkInvalidHeaderChar\r\nconst checkIsHttpToken = common.checkIsHttpToken\r\n\r\nfunction sanitizeName (name) {\r\n  name += ''\r\n  if (!checkIsHttpToken(name)) {\r\n    throw new TypeError(`${name} is not a legal HTTP header name`)\r\n  }\r\n  return name.toLowerCase()\r\n}\r\n\r\nfunction sanitizeValue (value) {\r\n  value += ''\r\n  if (checkInvalidHeaderChar(value)) {\r\n    throw new TypeError(`${value} is not a legal HTTP header value`)\r\n  }\r\n  return value\r\n}\r\n\r\nconst MAP = Symbol('map')\r\nclass Headers {\r\n  /**\r\n   * Headers class\r\n   *\r\n   * @param   Object  headers  Response headers\r\n   * @return  Void\r\n   */\r\n  constructor (init) {\r\n    this[MAP] = Object.create(null)\r\n\r\n    if (init instanceof Headers) {\r\n      const rawHeaders = init.raw()\r\n      const headerNames = Object.keys(rawHeaders)\r\n\r\n      for (const headerName of headerNames) {\r\n        for (const value of rawHeaders[headerName]) {\r\n          this.append(headerName, value)\r\n        }\r\n      }\r\n\r\n      return\r\n    }\r\n\r\n    // We don't worry about converting prop to ByteString here as append()\r\n    // will handle it.\r\n    if (init == null) {\r\n      // no op\r\n    } else if (typeof init === 'object') {\r\n      const method = init[Symbol.iterator]\r\n      if (method != null) {\r\n        if (typeof method !== 'function') {\r\n          throw new TypeError('Header pairs must be iterable')\r\n        }\r\n\r\n        // sequence<sequence<ByteString>>\r\n        // Note: per spec we have to first exhaust the lists then process them\r\n        const pairs = []\r\n        for (const pair of init) {\r\n          if (typeof pair !== 'object' || typeof pair[Symbol.iterator] !== 'function') {\r\n            throw new TypeError('Each header pair must be iterable')\r\n          }\r\n          pairs.push(Array.from(pair))\r\n        }\r\n\r\n        for (const pair of pairs) {\r\n          if (pair.length !== 2) {\r\n            throw new TypeError('Each header pair must be a name/value tuple')\r\n          }\r\n          this.append(pair[0], pair[1])\r\n        }\r\n      } else {\r\n        // record<ByteString, ByteString>\r\n        for (const key of Object.keys(init)) {\r\n          const value = init[key]\r\n          this.append(key, value)\r\n        }\r\n      }\r\n    } else {\r\n      throw new TypeError('Provided initializer must be an object')\r\n    }\r\n\r\n    Object.defineProperty(this, Symbol.toStringTag, {\r\n      value: 'Headers',\r\n      writable: false,\r\n      enumerable: false,\r\n      configurable: true\r\n    })\r\n  }\r\n\r\n  /**\r\n   * Return first header value given name\r\n   *\r\n   * @param   String  name  Header name\r\n   * @return  Mixed\r\n   */\r\n  get (name) {\r\n    const list = this[MAP][sanitizeName(name)]\r\n    if (!list) {\r\n      return null\r\n    }\r\n\r\n    return list.join(', ')\r\n  }\r\n\r\n  /**\r\n   * Iterate over all headers\r\n   *\r\n   * @param   Function  callback  Executed for each item with parameters (value, name, thisArg)\r\n   * @param   Boolean   thisArg   `this` context for callback function\r\n   * @return  Void\r\n   */\r\n  forEach (callback, thisArg) {\r\n    let pairs = getHeaderPairs(this)\r\n    let i = 0\r\n    while (i < pairs.length) {\r\n      const name = pairs[i][0]\r\n      const value = pairs[i][1]\r\n      callback.call(thisArg, value, name, this)\r\n      pairs = getHeaderPairs(this)\r\n      i++\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Overwrite header values given name\r\n   *\r\n   * @param   String  name   Header name\r\n   * @param   String  value  Header value\r\n   * @return  Void\r\n   */\r\n  set (name, value) {\r\n    this[MAP][sanitizeName(name)] = [sanitizeValue(value)]\r\n  }\r\n\r\n  /**\r\n   * Append a value onto existing header\r\n   *\r\n   * @param   String  name   Header name\r\n   * @param   String  value  Header value\r\n   * @return  Void\r\n   */\r\n  append (name, value) {\r\n    if (!this.has(name)) {\r\n      this.set(name, value)\r\n      return\r\n    }\r\n\r\n    this[MAP][sanitizeName(name)].push(sanitizeValue(value))\r\n  }\r\n\r\n  /**\r\n   * Check for header name existence\r\n   *\r\n   * @param   String   name  Header name\r\n   * @return  Boolean\r\n   */\r\n  has (name) {\r\n    return !!this[MAP][sanitizeName(name)]\r\n  }\r\n\r\n  /**\r\n   * Delete all header values given name\r\n   *\r\n   * @param   String  name  Header name\r\n   * @return  Void\r\n   */\r\n  delete (name) {\r\n    delete this[MAP][sanitizeName(name)]\r\n  };\r\n\r\n  /**\r\n   * Return raw headers (non-spec api)\r\n   *\r\n   * @return  Object\r\n   */\r\n  raw () {\r\n    return this[MAP]\r\n  }\r\n\r\n  /**\r\n   * Get an iterator on keys.\r\n   *\r\n   * @return  Iterator\r\n   */\r\n  keys () {\r\n    return createHeadersIterator(this, 'key')\r\n  }\r\n\r\n  /**\r\n   * Get an iterator on values.\r\n   *\r\n   * @return  Iterator\r\n   */\r\n  values () {\r\n    return createHeadersIterator(this, 'value')\r\n  }\r\n\r\n  /**\r\n   * Get an iterator on entries.\r\n   *\r\n   * This is the default iterator of the Headers object.\r\n   *\r\n   * @return  Iterator\r\n   */\r\n  [Symbol.iterator] () {\r\n    return createHeadersIterator(this, 'key+value')\r\n  }\r\n}\r\nHeaders.prototype.entries = Headers.prototype[Symbol.iterator]\r\n\r\nObject.defineProperty(Headers.prototype, Symbol.toStringTag, {\r\n  value: 'HeadersPrototype',\r\n  writable: false,\r\n  enumerable: false,\r\n  configurable: true\r\n})\r\n\r\nfunction getHeaderPairs (headers, kind) {\r\n  const keys = Object.keys(headers[MAP]).sort()\r\n  return keys.map(\r\n    kind === 'key'\r\n      ? k => [k]\r\n      : k => [k, headers.get(k)]\r\n  )\r\n}\r\n\r\nconst INTERNAL = Symbol('internal')\r\n\r\nfunction createHeadersIterator (target, kind) {\r\n  const iterator = Object.create(HeadersIteratorPrototype)\r\n  iterator[INTERNAL] = {\r\n    target,\r\n    kind,\r\n    index: 0\r\n  }\r\n  return iterator\r\n}\r\n\r\nconst HeadersIteratorPrototype = Object.setPrototypeOf({\r\n  next () {\r\n    // istanbul ignore if\r\n    if (!this ||\r\n      Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {\r\n      throw new TypeError('Value of `this` is not a HeadersIterator')\r\n    }\r\n\r\n    const target = this[INTERNAL].target\r\n    const kind = this[INTERNAL].kind\r\n    const index = this[INTERNAL].index\r\n    const values = getHeaderPairs(target, kind)\r\n    const len = values.length\r\n    if (index >= len) {\r\n      return {\r\n        value: undefined,\r\n        done: true\r\n      }\r\n    }\r\n\r\n    const pair = values[index]\r\n    this[INTERNAL].index = index + 1\r\n\r\n    let result\r\n    if (kind === 'key') {\r\n      result = pair[0]\r\n    } else if (kind === 'value') {\r\n      result = pair[1]\r\n    } else {\r\n      result = pair\r\n    }\r\n\r\n    return {\r\n      value: result,\r\n      done: false\r\n    }\r\n  }\r\n}, Object.getPrototypeOf(\r\n  Object.getPrototypeOf([][Symbol.iterator]())\r\n))\r\n\r\nObject.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {\r\n  value: 'HeadersIterator',\r\n  writable: false,\r\n  enumerable: false,\r\n  configurable: true\r\n})\r\n\r\nmodule.exports = Headers\r\n"]},"metadata":{},"sourceType":"script"}