{"ast":null,"code":"'use strict';\n\nconst path = require('path');\n\nconst fs = require('graceful-fs');\n\nconst chain = require('slide').chain;\n\nconst mkdir = require('./mkdir.js');\n\nconst rm = require('./rm.js');\n\nconst inferOwner = require('infer-owner');\n\nconst chown = require('./chown.js');\n\nexports = module.exports = {\n  link: link,\n  linkIfExists: linkIfExists\n};\n\nfunction linkIfExists(from, to, opts, cb) {\n  opts.currentIsLink = false;\n  opts.currentExists = false;\n  fs.stat(from, function (er) {\n    if (er) return cb();\n    fs.readlink(to, function (er, fromOnDisk) {\n      if (!er || er.code !== 'ENOENT') {\n        opts.currentExists = true;\n      } // if the link already exists and matches what we would do,\n      // we don't need to do anything\n\n\n      if (!er) {\n        opts.currentIsLink = true;\n        var toDir = path.dirname(to);\n        var absoluteFrom = path.resolve(toDir, from);\n        var absoluteFromOnDisk = path.resolve(toDir, fromOnDisk);\n        opts.currentTarget = absoluteFromOnDisk;\n        if (absoluteFrom === absoluteFromOnDisk) return cb();\n      }\n\n      link(from, to, opts, cb);\n    });\n  });\n}\n\nfunction resolveIfSymlink(maybeSymlinkPath, cb) {\n  fs.lstat(maybeSymlinkPath, function (err, stat) {\n    if (err) return cb.apply(this, arguments);\n    if (!stat.isSymbolicLink()) return cb(null, maybeSymlinkPath);\n    fs.readlink(maybeSymlinkPath, cb);\n  });\n}\n\nfunction ensureFromIsNotSource(from, to, cb) {\n  resolveIfSymlink(from, function (err, fromDestination) {\n    if (err) return cb.apply(this, arguments);\n\n    if (path.resolve(path.dirname(from), fromDestination) === path.resolve(to)) {\n      return cb(new Error('Link target resolves to the same directory as link source: ' + to));\n    }\n\n    cb.apply(this, arguments);\n  });\n}\n\nfunction link(from, to, opts, cb) {\n  to = path.resolve(to);\n  opts.base = path.dirname(to);\n  var absTarget = path.resolve(opts.base, from);\n  var relativeTarget = path.relative(opts.base, absTarget);\n  var target = opts.absolute ? absTarget : relativeTarget;\n  const tasks = [[ensureFromIsNotSource, absTarget, to], [fs, 'stat', absTarget], [clobberLinkGently, from, to, opts], [mkdir, path.dirname(to)], [fs, 'symlink', target, to, 'junction']];\n\n  if (chown.selfOwner.uid !== 0) {\n    chain(tasks, cb);\n  } else {\n    inferOwner(to).then(owner => {\n      tasks.push([chown, to, owner.uid, owner.gid]);\n      chain(tasks, cb);\n    });\n  }\n}\n\nexports._clobberLinkGently = clobberLinkGently;\n\nfunction clobberLinkGently(from, to, opts, cb) {\n  if (opts.currentExists === false) {\n    // nothing to clobber!\n    opts.log.silly('gently link', 'link does not already exist', {\n      link: to,\n      target: from\n    });\n    return cb();\n  }\n\n  if (!opts.clobberLinkGently || opts.force === true || !opts.gently || typeof opts.gently !== 'string') {\n    opts.log.silly('gently link', 'deleting existing link forcefully', {\n      link: to,\n      target: from,\n      force: opts.force,\n      gently: opts.gently,\n      clobberLinkGently: opts.clobberLinkGently\n    });\n    return rm(to, opts, cb);\n  }\n\n  if (!opts.currentIsLink) {\n    opts.log.verbose('gently link', 'cannot remove, not a link', to); // don't delete.  it'll fail with EEXIST when it tries to symlink.\n\n    return cb();\n  }\n\n  if (opts.currentTarget.indexOf(opts.gently) === 0) {\n    opts.log.silly('gently link', 'delete existing link', to);\n    return rm(to, opts, cb);\n  } else {\n    opts.log.verbose('gently link', 'refusing to delete existing link', {\n      link: to,\n      currentTarget: opts.currentTarget,\n      newTarget: from,\n      gently: opts.gently\n    });\n    return cb();\n  }\n}","map":{"version":3,"sources":["D:/node_modules/npm/node_modules/gentle-fs/lib/link.js"],"names":["path","require","fs","chain","mkdir","rm","inferOwner","chown","exports","module","link","linkIfExists","from","to","opts","cb","currentIsLink","currentExists","stat","er","readlink","fromOnDisk","code","toDir","dirname","absoluteFrom","resolve","absoluteFromOnDisk","currentTarget","resolveIfSymlink","maybeSymlinkPath","lstat","err","apply","arguments","isSymbolicLink","ensureFromIsNotSource","fromDestination","Error","base","absTarget","relativeTarget","relative","target","absolute","tasks","clobberLinkGently","selfOwner","uid","then","owner","push","gid","_clobberLinkGently","log","silly","force","gently","verbose","indexOf","newTarget"],"mappings":"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","sourcesContent":["'use strict'\r\n\r\nconst path = require('path')\r\nconst fs = require('graceful-fs')\r\nconst chain = require('slide').chain\r\nconst mkdir = require('./mkdir.js')\r\nconst rm = require('./rm.js')\r\nconst inferOwner = require('infer-owner')\r\nconst chown = require('./chown.js')\r\n\r\nexports = module.exports = {\r\n  link: link,\r\n  linkIfExists: linkIfExists\r\n}\r\n\r\nfunction linkIfExists (from, to, opts, cb) {\r\n  opts.currentIsLink = false\r\n  opts.currentExists = false\r\n  fs.stat(from, function (er) {\r\n    if (er) return cb()\r\n    fs.readlink(to, function (er, fromOnDisk) {\r\n      if (!er || er.code !== 'ENOENT') {\r\n        opts.currentExists = true\r\n      }\r\n      // if the link already exists and matches what we would do,\r\n      // we don't need to do anything\r\n      if (!er) {\r\n        opts.currentIsLink = true\r\n        var toDir = path.dirname(to)\r\n        var absoluteFrom = path.resolve(toDir, from)\r\n        var absoluteFromOnDisk = path.resolve(toDir, fromOnDisk)\r\n        opts.currentTarget = absoluteFromOnDisk\r\n        if (absoluteFrom === absoluteFromOnDisk) return cb()\r\n      }\r\n      link(from, to, opts, cb)\r\n    })\r\n  })\r\n}\r\n\r\nfunction resolveIfSymlink (maybeSymlinkPath, cb) {\r\n  fs.lstat(maybeSymlinkPath, function (err, stat) {\r\n    if (err) return cb.apply(this, arguments)\r\n    if (!stat.isSymbolicLink()) return cb(null, maybeSymlinkPath)\r\n    fs.readlink(maybeSymlinkPath, cb)\r\n  })\r\n}\r\n\r\nfunction ensureFromIsNotSource (from, to, cb) {\r\n  resolveIfSymlink(from, function (err, fromDestination) {\r\n    if (err) return cb.apply(this, arguments)\r\n    if (path.resolve(path.dirname(from), fromDestination) === path.resolve(to)) {\r\n      return cb(new Error('Link target resolves to the same directory as link source: ' + to))\r\n    }\r\n    cb.apply(this, arguments)\r\n  })\r\n}\r\n\r\nfunction link (from, to, opts, cb) {\r\n  to = path.resolve(to)\r\n  opts.base = path.dirname(to)\r\n  var absTarget = path.resolve(opts.base, from)\r\n  var relativeTarget = path.relative(opts.base, absTarget)\r\n  var target = opts.absolute ? absTarget : relativeTarget\r\n\r\n  const tasks = [\r\n    [ensureFromIsNotSource, absTarget, to],\r\n    [fs, 'stat', absTarget],\r\n    [clobberLinkGently, from, to, opts],\r\n    [mkdir, path.dirname(to)],\r\n    [fs, 'symlink', target, to, 'junction']\r\n  ]\r\n\r\n  if (chown.selfOwner.uid !== 0) {\r\n    chain(tasks, cb)\r\n  } else {\r\n    inferOwner(to).then(owner => {\r\n      tasks.push([chown, to, owner.uid, owner.gid])\r\n      chain(tasks, cb)\r\n    })\r\n  }\r\n}\r\n\r\nexports._clobberLinkGently = clobberLinkGently\r\nfunction clobberLinkGently (from, to, opts, cb) {\r\n  if (opts.currentExists === false) {\r\n    // nothing to clobber!\r\n    opts.log.silly('gently link', 'link does not already exist', {\r\n      link: to,\r\n      target: from\r\n    })\r\n    return cb()\r\n  }\r\n\r\n  if (!opts.clobberLinkGently ||\r\n      opts.force === true ||\r\n      !opts.gently ||\r\n      typeof opts.gently !== 'string') {\r\n    opts.log.silly('gently link', 'deleting existing link forcefully', {\r\n      link: to,\r\n      target: from,\r\n      force: opts.force,\r\n      gently: opts.gently,\r\n      clobberLinkGently: opts.clobberLinkGently\r\n    })\r\n    return rm(to, opts, cb)\r\n  }\r\n\r\n  if (!opts.currentIsLink) {\r\n    opts.log.verbose('gently link', 'cannot remove, not a link', to)\r\n    // don't delete.  it'll fail with EEXIST when it tries to symlink.\r\n    return cb()\r\n  }\r\n\r\n  if (opts.currentTarget.indexOf(opts.gently) === 0) {\r\n    opts.log.silly('gently link', 'delete existing link', to)\r\n    return rm(to, opts, cb)\r\n  } else {\r\n    opts.log.verbose('gently link', 'refusing to delete existing link', {\r\n      link: to,\r\n      currentTarget: opts.currentTarget,\r\n      newTarget: from,\r\n      gently: opts.gently\r\n    })\r\n    return cb()\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}