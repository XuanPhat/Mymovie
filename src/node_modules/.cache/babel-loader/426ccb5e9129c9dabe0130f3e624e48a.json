{"ast":null,"code":"'use strict';\n\nmodule.exports = parseJson;\n\nfunction parseJson(txt, reviver, context) {\n  context = context || 20;\n\n  try {\n    return JSON.parse(txt, reviver);\n  } catch (e) {\n    if (typeof txt !== 'string') {\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0;\n      const errorMessage = 'Cannot parse ' + (isEmptyArray ? 'an empty array' : String(txt));\n      throw new TypeError(errorMessage);\n    }\n\n    const syntaxErr = e.message.match(/^Unexpected token.*position\\s+(\\d+)/i);\n    const errIdx = syntaxErr ? +syntaxErr[1] : e.message.match(/^Unexpected end of JSON.*/i) ? txt.length - 1 : null;\n\n    if (errIdx != null) {\n      const start = errIdx <= context ? 0 : errIdx - context;\n      const end = errIdx + context >= txt.length ? txt.length : errIdx + context;\n      e.message += ` while parsing near '${start === 0 ? '' : '...'}${txt.slice(start, end)}${end === txt.length ? '' : '...'}'`;\n    } else {\n      e.message += ` while parsing '${txt.slice(0, context * 2)}'`;\n    }\n\n    throw e;\n  }\n}","map":{"version":3,"sources":["D:/node_modules/npm/node_modules/json-parse-better-errors/index.js"],"names":["module","exports","parseJson","txt","reviver","context","JSON","parse","e","isEmptyArray","Array","isArray","length","errorMessage","String","TypeError","syntaxErr","message","match","errIdx","start","end","slice"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,OAAP,GAAiBC,SAAjB;;AACA,SAASA,SAAT,CAAoBC,GAApB,EAAyBC,OAAzB,EAAkCC,OAAlC,EAA2C;AACzCA,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AACA,MAAI;AACF,WAAOC,IAAI,CAACC,KAAL,CAAWJ,GAAX,EAAgBC,OAAhB,CAAP;AACD,GAFD,CAEE,OAAOI,CAAP,EAAU;AACV,QAAI,OAAOL,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAMM,YAAY,GAAGC,KAAK,CAACC,OAAN,CAAcR,GAAd,KAAsBA,GAAG,CAACS,MAAJ,KAAe,CAA1D;AACA,YAAMC,YAAY,GAAG,mBACpBJ,YAAY,GAAG,gBAAH,GAAsBK,MAAM,CAACX,GAAD,CADpB,CAArB;AAEA,YAAM,IAAIY,SAAJ,CAAcF,YAAd,CAAN;AACD;;AACD,UAAMG,SAAS,GAAGR,CAAC,CAACS,OAAF,CAAUC,KAAV,CAAgB,sCAAhB,CAAlB;AACA,UAAMC,MAAM,GAAGH,SAAS,GACtB,CAACA,SAAS,CAAC,CAAD,CADY,GAEtBR,CAAC,CAACS,OAAF,CAAUC,KAAV,CAAgB,4BAAhB,IACAf,GAAG,CAACS,MAAJ,GAAa,CADb,GAEA,IAJF;;AAKA,QAAIO,MAAM,IAAI,IAAd,EAAoB;AAClB,YAAMC,KAAK,GAAGD,MAAM,IAAId,OAAV,GACZ,CADY,GAEZc,MAAM,GAAGd,OAFX;AAGA,YAAMgB,GAAG,GAAGF,MAAM,GAAGd,OAAT,IAAoBF,GAAG,CAACS,MAAxB,GACVT,GAAG,CAACS,MADM,GAEVO,MAAM,GAAGd,OAFX;AAGAG,MAAAA,CAAC,CAACS,OAAF,IAAc,wBACZG,KAAK,KAAK,CAAV,GAAc,EAAd,GAAmB,KACpB,GAAEjB,GAAG,CAACmB,KAAJ,CAAUF,KAAV,EAAiBC,GAAjB,CAAsB,GACvBA,GAAG,KAAKlB,GAAG,CAACS,MAAZ,GAAqB,EAArB,GAA0B,KAC3B,GAJD;AAKD,KAZD,MAYO;AACLJ,MAAAA,CAAC,CAACS,OAAF,IAAc,mBAAkBd,GAAG,CAACmB,KAAJ,CAAU,CAAV,EAAajB,OAAO,GAAG,CAAvB,CAA0B,GAA1D;AACD;;AACD,UAAMG,CAAN;AACD;AACF","sourcesContent":["'use strict'\r\n\r\nmodule.exports = parseJson\r\nfunction parseJson (txt, reviver, context) {\r\n  context = context || 20\r\n  try {\r\n    return JSON.parse(txt, reviver)\r\n  } catch (e) {\r\n    if (typeof txt !== 'string') {\r\n      const isEmptyArray = Array.isArray(txt) && txt.length === 0\r\n      const errorMessage = 'Cannot parse ' +\r\n      (isEmptyArray ? 'an empty array' : String(txt))\r\n      throw new TypeError(errorMessage)\r\n    }\r\n    const syntaxErr = e.message.match(/^Unexpected token.*position\\s+(\\d+)/i)\r\n    const errIdx = syntaxErr\r\n    ? +syntaxErr[1]\r\n    : e.message.match(/^Unexpected end of JSON.*/i)\r\n    ? txt.length - 1\r\n    : null\r\n    if (errIdx != null) {\r\n      const start = errIdx <= context\r\n      ? 0\r\n      : errIdx - context\r\n      const end = errIdx + context >= txt.length\r\n      ? txt.length\r\n      : errIdx + context\r\n      e.message += ` while parsing near '${\r\n        start === 0 ? '' : '...'\r\n      }${txt.slice(start, end)}${\r\n        end === txt.length ? '' : '...'\r\n      }'`\r\n    } else {\r\n      e.message += ` while parsing '${txt.slice(0, context * 2)}'`\r\n    }\r\n    throw e\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}