{"ast":null,"code":"'use strict';\n\nconst config = require('./config.js');\n\nconst errors = require('./errors.js');\n\nconst LRU = require('lru-cache');\n\nmodule.exports = checkResponse;\n\nfunction checkResponse(method, res, registry, startTime, opts) {\n  opts = config(opts);\n\n  if (res.headers.has('npm-notice') && !res.headers.has('x-local-cache')) {\n    opts.log.notice('', res.headers.get('npm-notice'));\n  }\n\n  checkWarnings(res, registry, opts);\n\n  if (res.status >= 400) {\n    logRequest(method, res, startTime, opts);\n    return checkErrors(method, res, startTime, opts);\n  } else {\n    res.body.on('end', () => logRequest(method, res, startTime, opts));\n\n    if (opts.ignoreBody) {\n      res.body.resume();\n      res.body = null;\n    }\n\n    return res;\n  }\n}\n\nfunction logRequest(method, res, startTime, opts) {\n  const elapsedTime = Date.now() - startTime;\n  const attempt = res.headers.get('x-fetch-attempts');\n  const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : '';\n  const cacheStr = res.headers.get('x-local-cache') ? ' (from cache)' : '';\n  opts.log.http('fetch', `${method.toUpperCase()} ${res.status} ${res.url} ${elapsedTime}ms${attemptStr}${cacheStr}`);\n}\n\nconst WARNING_REGEXP = /^\\s*(\\d{3})\\s+(\\S+)\\s+\"(.*)\"\\s+\"([^\"]+)\"/;\nconst BAD_HOSTS = new LRU({\n  max: 50\n});\n\nfunction checkWarnings(res, registry, opts) {\n  if (res.headers.has('warning') && !BAD_HOSTS.has(registry)) {\n    const warnings = {};\n    res.headers.raw()['warning'].forEach(w => {\n      const match = w.match(WARNING_REGEXP);\n\n      if (match) {\n        warnings[match[1]] = {\n          code: match[1],\n          host: match[2],\n          message: match[3],\n          date: new Date(match[4])\n        };\n      }\n    });\n    BAD_HOSTS.set(registry, true);\n\n    if (warnings['199']) {\n      if (warnings['199'].message.match(/ENOTFOUND/)) {\n        opts.log.warn('registry', `Using stale data from ${registry} because the host is inaccessible -- are you offline?`);\n      } else {\n        opts.log.warn('registry', `Unexpected warning for ${registry}: ${warnings['199'].message}`);\n      }\n    }\n\n    if (warnings['111']) {\n      // 111 Revalidation failed -- we're using stale data\n      opts.log.warn('registry', `Using stale data from ${registry} due to a request error during revalidation.`);\n    }\n  }\n}\n\nfunction checkErrors(method, res, startTime, opts) {\n  return res.buffer().catch(() => null).then(body => {\n    let parsed = body;\n\n    try {\n      parsed = JSON.parse(body.toString('utf8'));\n    } catch (e) {}\n\n    if (res.status === 401 && res.headers.get('www-authenticate')) {\n      const auth = res.headers.get('www-authenticate').split(/,\\s*/).map(s => s.toLowerCase());\n\n      if (auth.indexOf('ipaddress') !== -1) {\n        throw new errors.HttpErrorAuthIPAddress(method, res, parsed, opts.spec);\n      } else if (auth.indexOf('otp') !== -1) {\n        throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n      } else {\n        throw new errors.HttpErrorAuthUnknown(method, res, parsed, opts.spec);\n      }\n    } else if (res.status === 401 && body != null && /one-time pass/.test(body.toString('utf8'))) {\n      // Heuristic for malformed OTP responses that don't include the www-authenticate header.\n      throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);\n    } else {\n      throw new errors.HttpErrorGeneral(method, res, parsed, opts.spec);\n    }\n  });\n}","map":{"version":3,"sources":["D:/node_modules/npm/node_modules/npm-registry-fetch/check-response.js"],"names":["config","require","errors","LRU","module","exports","checkResponse","method","res","registry","startTime","opts","headers","has","log","notice","get","checkWarnings","status","logRequest","checkErrors","body","on","ignoreBody","resume","elapsedTime","Date","now","attempt","attemptStr","cacheStr","http","toUpperCase","url","WARNING_REGEXP","BAD_HOSTS","max","warnings","raw","forEach","w","match","code","host","message","date","set","warn","buffer","catch","then","parsed","JSON","parse","toString","e","auth","split","map","s","toLowerCase","indexOf","HttpErrorAuthIPAddress","spec","HttpErrorAuthOTP","HttpErrorAuthUnknown","test","HttpErrorGeneral"],"mappings":"AAAA;;AAEA,MAAMA,MAAM,GAAGC,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAMC,MAAM,GAAGD,OAAO,CAAC,aAAD,CAAtB;;AACA,MAAME,GAAG,GAAGF,OAAO,CAAC,WAAD,CAAnB;;AAEAG,MAAM,CAACC,OAAP,GAAiBC,aAAjB;;AACA,SAASA,aAAT,CAAwBC,MAAxB,EAAgCC,GAAhC,EAAqCC,QAArC,EAA+CC,SAA/C,EAA0DC,IAA1D,EAAgE;AAC9DA,EAAAA,IAAI,GAAGX,MAAM,CAACW,IAAD,CAAb;;AACA,MAAIH,GAAG,CAACI,OAAJ,CAAYC,GAAZ,CAAgB,YAAhB,KAAiC,CAACL,GAAG,CAACI,OAAJ,CAAYC,GAAZ,CAAgB,eAAhB,CAAtC,EAAwE;AACtEF,IAAAA,IAAI,CAACG,GAAL,CAASC,MAAT,CAAgB,EAAhB,EAAoBP,GAAG,CAACI,OAAJ,CAAYI,GAAZ,CAAgB,YAAhB,CAApB;AACD;;AACDC,EAAAA,aAAa,CAACT,GAAD,EAAMC,QAAN,EAAgBE,IAAhB,CAAb;;AACA,MAAIH,GAAG,CAACU,MAAJ,IAAc,GAAlB,EAAuB;AACrBC,IAAAA,UAAU,CAACZ,MAAD,EAASC,GAAT,EAAcE,SAAd,EAAyBC,IAAzB,CAAV;AACA,WAAOS,WAAW,CAACb,MAAD,EAASC,GAAT,EAAcE,SAAd,EAAyBC,IAAzB,CAAlB;AACD,GAHD,MAGO;AACLH,IAAAA,GAAG,CAACa,IAAJ,CAASC,EAAT,CAAY,KAAZ,EAAmB,MAAMH,UAAU,CAACZ,MAAD,EAASC,GAAT,EAAcE,SAAd,EAAyBC,IAAzB,CAAnC;;AACA,QAAIA,IAAI,CAACY,UAAT,EAAqB;AACnBf,MAAAA,GAAG,CAACa,IAAJ,CAASG,MAAT;AACAhB,MAAAA,GAAG,CAACa,IAAJ,GAAW,IAAX;AACD;;AACD,WAAOb,GAAP;AACD;AACF;;AAED,SAASW,UAAT,CAAqBZ,MAArB,EAA6BC,GAA7B,EAAkCE,SAAlC,EAA6CC,IAA7C,EAAmD;AACjD,QAAMc,WAAW,GAAGC,IAAI,CAACC,GAAL,KAAajB,SAAjC;AACA,QAAMkB,OAAO,GAAGpB,GAAG,CAACI,OAAJ,CAAYI,GAAZ,CAAgB,kBAAhB,CAAhB;AACA,QAAMa,UAAU,GAAGD,OAAO,IAAIA,OAAO,GAAG,CAArB,GAA0B,aAAYA,OAAQ,EAA9C,GAAkD,EAArE;AACA,QAAME,QAAQ,GAAGtB,GAAG,CAACI,OAAJ,CAAYI,GAAZ,CAAgB,eAAhB,IAAmC,eAAnC,GAAqD,EAAtE;AACAL,EAAAA,IAAI,CAACG,GAAL,CAASiB,IAAT,CACE,OADF,EAEG,GAAExB,MAAM,CAACyB,WAAP,EAAqB,IAAGxB,GAAG,CAACU,MAAO,IAAGV,GAAG,CAACyB,GAAI,IAAGR,WAAY,KAAII,UAAW,GAAEC,QAAS,EAF5F;AAID;;AAED,MAAMI,cAAc,GAAG,0CAAvB;AACA,MAAMC,SAAS,GAAG,IAAIhC,GAAJ,CAAQ;AAAEiC,EAAAA,GAAG,EAAE;AAAP,CAAR,CAAlB;;AAEA,SAASnB,aAAT,CAAwBT,GAAxB,EAA6BC,QAA7B,EAAuCE,IAAvC,EAA6C;AAC3C,MAAIH,GAAG,CAACI,OAAJ,CAAYC,GAAZ,CAAgB,SAAhB,KAA8B,CAACsB,SAAS,CAACtB,GAAV,CAAcJ,QAAd,CAAnC,EAA4D;AAC1D,UAAM4B,QAAQ,GAAG,EAAjB;AACA7B,IAAAA,GAAG,CAACI,OAAJ,CAAY0B,GAAZ,GAAkB,SAAlB,EAA6BC,OAA7B,CAAqCC,CAAC,IAAI;AACxC,YAAMC,KAAK,GAAGD,CAAC,CAACC,KAAF,CAAQP,cAAR,CAAd;;AACA,UAAIO,KAAJ,EAAW;AACTJ,QAAAA,QAAQ,CAACI,KAAK,CAAC,CAAD,CAAN,CAAR,GAAqB;AACnBC,UAAAA,IAAI,EAAED,KAAK,CAAC,CAAD,CADQ;AAEnBE,UAAAA,IAAI,EAAEF,KAAK,CAAC,CAAD,CAFQ;AAGnBG,UAAAA,OAAO,EAAEH,KAAK,CAAC,CAAD,CAHK;AAInBI,UAAAA,IAAI,EAAE,IAAInB,IAAJ,CAASe,KAAK,CAAC,CAAD,CAAd;AAJa,SAArB;AAMD;AACF,KAVD;AAWAN,IAAAA,SAAS,CAACW,GAAV,CAAcrC,QAAd,EAAwB,IAAxB;;AACA,QAAI4B,QAAQ,CAAC,KAAD,CAAZ,EAAqB;AACnB,UAAIA,QAAQ,CAAC,KAAD,CAAR,CAAgBO,OAAhB,CAAwBH,KAAxB,CAA8B,WAA9B,CAAJ,EAAgD;AAC9C9B,QAAAA,IAAI,CAACG,GAAL,CAASiC,IAAT,CAAc,UAAd,EAA2B,yBAAwBtC,QAAS,uDAA5D;AACD,OAFD,MAEO;AACLE,QAAAA,IAAI,CAACG,GAAL,CAASiC,IAAT,CAAc,UAAd,EAA2B,0BAAyBtC,QAAS,KAAI4B,QAAQ,CAAC,KAAD,CAAR,CAAgBO,OAAQ,EAAzF;AACD;AACF;;AACD,QAAIP,QAAQ,CAAC,KAAD,CAAZ,EAAqB;AACnB;AACA1B,MAAAA,IAAI,CAACG,GAAL,CAASiC,IAAT,CACE,UADF,EAEG,yBAAwBtC,QAAS,8CAFpC;AAID;AACF;AACF;;AAED,SAASW,WAAT,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCE,SAAnC,EAA8CC,IAA9C,EAAoD;AAClD,SAAOH,GAAG,CAACwC,MAAJ,GACJC,KADI,CACE,MAAM,IADR,EAEJC,IAFI,CAEC7B,IAAI,IAAI;AACZ,QAAI8B,MAAM,GAAG9B,IAAb;;AACA,QAAI;AACF8B,MAAAA,MAAM,GAAGC,IAAI,CAACC,KAAL,CAAWhC,IAAI,CAACiC,QAAL,CAAc,MAAd,CAAX,CAAT;AACD,KAFD,CAEE,OAAOC,CAAP,EAAU,CAAE;;AACd,QAAI/C,GAAG,CAACU,MAAJ,KAAe,GAAf,IAAsBV,GAAG,CAACI,OAAJ,CAAYI,GAAZ,CAAgB,kBAAhB,CAA1B,EAA+D;AAC7D,YAAMwC,IAAI,GAAGhD,GAAG,CAACI,OAAJ,CAAYI,GAAZ,CAAgB,kBAAhB,EACVyC,KADU,CACJ,MADI,EAEVC,GAFU,CAENC,CAAC,IAAIA,CAAC,CAACC,WAAF,EAFC,CAAb;;AAGA,UAAIJ,IAAI,CAACK,OAAL,CAAa,WAAb,MAA8B,CAAC,CAAnC,EAAsC;AACpC,cAAM,IAAI3D,MAAM,CAAC4D,sBAAX,CACJvD,MADI,EACIC,GADJ,EACS2C,MADT,EACiBxC,IAAI,CAACoD,IADtB,CAAN;AAGD,OAJD,MAIO,IAAIP,IAAI,CAACK,OAAL,CAAa,KAAb,MAAwB,CAAC,CAA7B,EAAgC;AACrC,cAAM,IAAI3D,MAAM,CAAC8D,gBAAX,CACJzD,MADI,EACIC,GADJ,EACS2C,MADT,EACiBxC,IAAI,CAACoD,IADtB,CAAN;AAGD,OAJM,MAIA;AACL,cAAM,IAAI7D,MAAM,CAAC+D,oBAAX,CACJ1D,MADI,EACIC,GADJ,EACS2C,MADT,EACiBxC,IAAI,CAACoD,IADtB,CAAN;AAGD;AACF,KAjBD,MAiBO,IAAIvD,GAAG,CAACU,MAAJ,KAAe,GAAf,IAAsBG,IAAI,IAAI,IAA9B,IAAsC,gBAAgB6C,IAAhB,CAAqB7C,IAAI,CAACiC,QAAL,CAAc,MAAd,CAArB,CAA1C,EAAuF;AAC5F;AACA,YAAM,IAAIpD,MAAM,CAAC8D,gBAAX,CACJzD,MADI,EACIC,GADJ,EACS2C,MADT,EACiBxC,IAAI,CAACoD,IADtB,CAAN;AAGD,KALM,MAKA;AACL,YAAM,IAAI7D,MAAM,CAACiE,gBAAX,CACJ5D,MADI,EACIC,GADJ,EACS2C,MADT,EACiBxC,IAAI,CAACoD,IADtB,CAAN;AAGD;AACF,GAlCI,CAAP;AAmCD","sourcesContent":["'use strict'\r\n\r\nconst config = require('./config.js')\r\nconst errors = require('./errors.js')\r\nconst LRU = require('lru-cache')\r\n\r\nmodule.exports = checkResponse\r\nfunction checkResponse (method, res, registry, startTime, opts) {\r\n  opts = config(opts)\r\n  if (res.headers.has('npm-notice') && !res.headers.has('x-local-cache')) {\r\n    opts.log.notice('', res.headers.get('npm-notice'))\r\n  }\r\n  checkWarnings(res, registry, opts)\r\n  if (res.status >= 400) {\r\n    logRequest(method, res, startTime, opts)\r\n    return checkErrors(method, res, startTime, opts)\r\n  } else {\r\n    res.body.on('end', () => logRequest(method, res, startTime, opts))\r\n    if (opts.ignoreBody) {\r\n      res.body.resume()\r\n      res.body = null\r\n    }\r\n    return res\r\n  }\r\n}\r\n\r\nfunction logRequest (method, res, startTime, opts) {\r\n  const elapsedTime = Date.now() - startTime\r\n  const attempt = res.headers.get('x-fetch-attempts')\r\n  const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : ''\r\n  const cacheStr = res.headers.get('x-local-cache') ? ' (from cache)' : ''\r\n  opts.log.http(\r\n    'fetch',\r\n    `${method.toUpperCase()} ${res.status} ${res.url} ${elapsedTime}ms${attemptStr}${cacheStr}`\r\n  )\r\n}\r\n\r\nconst WARNING_REGEXP = /^\\s*(\\d{3})\\s+(\\S+)\\s+\"(.*)\"\\s+\"([^\"]+)\"/\r\nconst BAD_HOSTS = new LRU({ max: 50 })\r\n\r\nfunction checkWarnings (res, registry, opts) {\r\n  if (res.headers.has('warning') && !BAD_HOSTS.has(registry)) {\r\n    const warnings = {}\r\n    res.headers.raw()['warning'].forEach(w => {\r\n      const match = w.match(WARNING_REGEXP)\r\n      if (match) {\r\n        warnings[match[1]] = {\r\n          code: match[1],\r\n          host: match[2],\r\n          message: match[3],\r\n          date: new Date(match[4])\r\n        }\r\n      }\r\n    })\r\n    BAD_HOSTS.set(registry, true)\r\n    if (warnings['199']) {\r\n      if (warnings['199'].message.match(/ENOTFOUND/)) {\r\n        opts.log.warn('registry', `Using stale data from ${registry} because the host is inaccessible -- are you offline?`)\r\n      } else {\r\n        opts.log.warn('registry', `Unexpected warning for ${registry}: ${warnings['199'].message}`)\r\n      }\r\n    }\r\n    if (warnings['111']) {\r\n      // 111 Revalidation failed -- we're using stale data\r\n      opts.log.warn(\r\n        'registry',\r\n        `Using stale data from ${registry} due to a request error during revalidation.`\r\n      )\r\n    }\r\n  }\r\n}\r\n\r\nfunction checkErrors (method, res, startTime, opts) {\r\n  return res.buffer()\r\n    .catch(() => null)\r\n    .then(body => {\r\n      let parsed = body\r\n      try {\r\n        parsed = JSON.parse(body.toString('utf8'))\r\n      } catch (e) {}\r\n      if (res.status === 401 && res.headers.get('www-authenticate')) {\r\n        const auth = res.headers.get('www-authenticate')\r\n          .split(/,\\s*/)\r\n          .map(s => s.toLowerCase())\r\n        if (auth.indexOf('ipaddress') !== -1) {\r\n          throw new errors.HttpErrorAuthIPAddress(\r\n            method, res, parsed, opts.spec\r\n          )\r\n        } else if (auth.indexOf('otp') !== -1) {\r\n          throw new errors.HttpErrorAuthOTP(\r\n            method, res, parsed, opts.spec\r\n          )\r\n        } else {\r\n          throw new errors.HttpErrorAuthUnknown(\r\n            method, res, parsed, opts.spec\r\n          )\r\n        }\r\n      } else if (res.status === 401 && body != null && /one-time pass/.test(body.toString('utf8'))) {\r\n        // Heuristic for malformed OTP responses that don't include the www-authenticate header.\r\n        throw new errors.HttpErrorAuthOTP(\r\n          method, res, parsed, opts.spec\r\n        )\r\n      } else {\r\n        throw new errors.HttpErrorGeneral(\r\n          method, res, parsed, opts.spec\r\n        )\r\n      }\r\n    })\r\n}\r\n"]},"metadata":{},"sourceType":"script"}