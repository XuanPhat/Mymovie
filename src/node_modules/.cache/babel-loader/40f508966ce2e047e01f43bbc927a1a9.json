{"ast":null,"code":"const idRegex = /^[a-z0-9-]{1,32}$/;\nconst nameRegex = /^[a-z0-9-]{1,32}$/;\nconst valueRegex = /^[a-zA-Z0-9/+.-]+$/;\nconst b64Regex = /^([a-zA-Z0-9/+.-]+|)$/;\nconst decimalRegex = /^((-)?[1-9]\\d*|0)$/;\nconst versionRegex = /^v=(\\d+)$/;\n\nfunction objToKeyVal(obj) {\n  return objectKeys(obj).map(k => [k, obj[k]].join('=')).join(',');\n}\n\nfunction keyValtoObj(str) {\n  const obj = {};\n  str.split(',').forEach(ps => {\n    const pss = ps.split('=');\n\n    if (pss.length < 2) {\n      throw new TypeError(`params must be in the format name=value`);\n    }\n\n    obj[pss.shift()] = pss.join('=');\n  });\n  return obj;\n}\n\nfunction objectKeys(object) {\n  /* istanbul ignore next */\n  return Object.keys(object);\n}\n\nfunction objectValues(object) {\n  /* istanbul ignore next */\n  if (typeof Object.values === 'function') return Object.values(object);\n  /* istanbul ignore next */\n\n  return objectKeys(object).map(k => object[k]);\n}\n/**\n * Generates a PHC string using the data provided.\n * @param  {Object} opts Object that holds the data needed to generate the PHC\n * string.\n * @param  {string} opts.id Symbolic name for the function.\n * @param  {Number} [opts.version] The version of the function.\n * @param  {Object} [opts.params] Parameters of the function.\n * @param  {Buffer} [opts.salt] The salt as a binary buffer.\n * @param  {Buffer} [opts.hash] The hash as a binary buffer.\n * @return {string} The hash string adhering to the PHC format.\n */\n\n\nfunction serialize(opts) {\n  const fields = [''];\n\n  if (typeof opts !== 'object' || opts === null) {\n    throw new TypeError('opts must be an object');\n  } // Identifier Validation\n\n\n  if (typeof opts.id !== 'string') {\n    throw new TypeError('id must be a string');\n  }\n\n  if (!idRegex.test(opts.id)) {\n    throw new TypeError(`id must satisfy ${idRegex}`);\n  }\n\n  fields.push(opts.id);\n\n  if (typeof opts.version !== 'undefined') {\n    if (typeof opts.version !== 'number' || opts.version < 0 || !Number.isInteger(opts.version)) {\n      throw new TypeError('version must be a positive integer number');\n    }\n\n    fields.push(`v=${opts.version}`);\n  } // Parameters Validation\n\n\n  if (typeof opts.params !== 'undefined') {\n    if (typeof opts.params !== 'object' || opts.params === null) {\n      throw new TypeError('params must be an object');\n    }\n\n    const pk = objectKeys(opts.params);\n\n    if (!pk.every(p => nameRegex.test(p))) {\n      throw new TypeError(`params names must satisfy ${nameRegex}`);\n    } // Convert Numbers into Numeric Strings and Buffers into B64 encoded strings.\n\n\n    pk.forEach(k => {\n      if (typeof opts.params[k] === 'number') {\n        opts.params[k] = opts.params[k].toString();\n      } else if (Buffer.isBuffer(opts.params[k])) {\n        opts.params[k] = opts.params[k].toString('base64').split('=')[0];\n      }\n    });\n    const pv = objectValues(opts.params);\n\n    if (!pv.every(v => typeof v === 'string')) {\n      throw new TypeError('params values must be strings');\n    }\n\n    if (!pv.every(v => valueRegex.test(v))) {\n      throw new TypeError(`params values must satisfy ${valueRegex}`);\n    }\n\n    const strpar = objToKeyVal(opts.params);\n    fields.push(strpar);\n  }\n\n  if (typeof opts.salt !== 'undefined') {\n    // Salt Validation\n    if (!Buffer.isBuffer(opts.salt)) {\n      throw new TypeError('salt must be a Buffer');\n    }\n\n    fields.push(opts.salt.toString('base64').split('=')[0]);\n\n    if (typeof opts.hash !== 'undefined') {\n      // Hash Validation\n      if (!Buffer.isBuffer(opts.hash)) {\n        throw new TypeError('hash must be a Buffer');\n      }\n\n      fields.push(opts.hash.toString('base64').split('=')[0]);\n    }\n  } // Create the PHC formatted string\n\n\n  const phcstr = fields.join('$');\n  return phcstr;\n}\n/**\n * Parses data from a PHC string.\n * @param  {string} phcstr A PHC string to parse.\n * @return {Object} The object containing the data parsed from the PHC string.\n */\n\n\nfunction deserialize(phcstr) {\n  if (typeof phcstr !== 'string' || phcstr === '') {\n    throw new TypeError('pchstr must be a non-empty string');\n  }\n\n  if (phcstr[0] !== '$') {\n    throw new TypeError('pchstr must contain a $ as first char');\n  }\n\n  const fields = phcstr.split('$'); // Remove first empty $\n\n  fields.shift(); // Parse Fields\n\n  let maxf = 5;\n  if (!versionRegex.test(fields[1])) maxf--;\n\n  if (fields.length > maxf) {\n    throw new TypeError(`pchstr contains too many fileds: ${fields.length}/${maxf}`);\n  } // Parse Identifier\n\n\n  const id = fields.shift();\n\n  if (!idRegex.test(id)) {\n    throw new TypeError(`id must satisfy ${idRegex}`);\n  }\n\n  let version; // Parse Version\n\n  if (versionRegex.test(fields[0])) {\n    version = parseInt(fields.shift().match(versionRegex)[1], 10);\n  }\n\n  let hash;\n  let salt;\n\n  if (b64Regex.test(fields[fields.length - 1])) {\n    if (fields.length > 1 && b64Regex.test(fields[fields.length - 2])) {\n      // Parse Hash\n      hash = Buffer.from(fields.pop(), 'base64'); // Parse Salt\n\n      salt = Buffer.from(fields.pop(), 'base64');\n    } else {\n      // Parse Salt\n      salt = Buffer.from(fields.pop(), 'base64');\n    }\n  } // Parse Parameters\n\n\n  let params;\n\n  if (fields.length > 0) {\n    const parstr = fields.pop();\n    params = keyValtoObj(parstr);\n\n    if (!objectKeys(params).every(p => nameRegex.test(p))) {\n      throw new TypeError(`params names must satisfy ${nameRegex}`);\n    }\n\n    const pv = objectValues(params);\n\n    if (!pv.every(v => valueRegex.test(v))) {\n      throw new TypeError(`params values must satisfy ${valueRegex}`);\n    }\n\n    const pk = objectKeys(params); // Convert Decimal Strings into Numbers\n\n    pk.forEach(k => {\n      params[k] = decimalRegex.test(params[k]) ? parseInt(params[k], 10) : params[k];\n    });\n  }\n\n  if (fields.length > 0) {\n    throw new TypeError(`pchstr contains unrecognized fileds: ${fields}`);\n  } // Build the output object\n\n\n  const phcobj = {\n    id\n  };\n  if (version) phcobj.version = version;\n  if (params) phcobj.params = params;\n  if (salt) phcobj.salt = salt;\n  if (hash) phcobj.hash = hash;\n  return phcobj;\n}\n\nmodule.exports = {\n  serialize,\n  deserialize\n};","map":{"version":3,"sources":["D:/ReactJS/reactjsstart/my-app/node_modules/@phc/format/index.js"],"names":["idRegex","nameRegex","valueRegex","b64Regex","decimalRegex","versionRegex","objToKeyVal","obj","objectKeys","map","k","join","keyValtoObj","str","split","forEach","ps","pss","length","TypeError","shift","object","Object","keys","objectValues","values","serialize","opts","fields","id","test","push","version","Number","isInteger","params","pk","every","p","toString","Buffer","isBuffer","pv","v","strpar","salt","hash","phcstr","deserialize","maxf","parseInt","match","from","pop","parstr","phcobj","module","exports"],"mappings":"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","sourcesContent":["const idRegex = /^[a-z0-9-]{1,32}$/;\nconst nameRegex = /^[a-z0-9-]{1,32}$/;\nconst valueRegex = /^[a-zA-Z0-9/+.-]+$/;\nconst b64Regex = /^([a-zA-Z0-9/+.-]+|)$/;\nconst decimalRegex = /^((-)?[1-9]\\d*|0)$/;\nconst versionRegex = /^v=(\\d+)$/;\n\nfunction objToKeyVal(obj) {\n  return objectKeys(obj)\n    .map(k => [k, obj[k]].join('='))\n    .join(',');\n}\n\nfunction keyValtoObj(str) {\n  const obj = {};\n  str.split(',').forEach(ps => {\n    const pss = ps.split('=');\n    if (pss.length < 2) {\n      throw new TypeError(`params must be in the format name=value`);\n    }\n\n    obj[pss.shift()] = pss.join('=');\n  });\n  return obj;\n}\n\nfunction objectKeys(object) {\n  /* istanbul ignore next */\n  return Object.keys(object);\n}\n\nfunction objectValues(object) {\n  /* istanbul ignore next */\n  if (typeof Object.values === 'function') return Object.values(object);\n  /* istanbul ignore next */\n  return objectKeys(object).map(k => object[k]);\n}\n\n/**\n * Generates a PHC string using the data provided.\n * @param  {Object} opts Object that holds the data needed to generate the PHC\n * string.\n * @param  {string} opts.id Symbolic name for the function.\n * @param  {Number} [opts.version] The version of the function.\n * @param  {Object} [opts.params] Parameters of the function.\n * @param  {Buffer} [opts.salt] The salt as a binary buffer.\n * @param  {Buffer} [opts.hash] The hash as a binary buffer.\n * @return {string} The hash string adhering to the PHC format.\n */\nfunction serialize(opts) {\n  const fields = [''];\n\n  if (typeof opts !== 'object' || opts === null) {\n    throw new TypeError('opts must be an object');\n  }\n\n  // Identifier Validation\n  if (typeof opts.id !== 'string') {\n    throw new TypeError('id must be a string');\n  }\n\n  if (!idRegex.test(opts.id)) {\n    throw new TypeError(`id must satisfy ${idRegex}`);\n  }\n\n  fields.push(opts.id);\n\n  if (typeof opts.version !== 'undefined') {\n    if (\n      typeof opts.version !== 'number' ||\n      opts.version < 0 ||\n      !Number.isInteger(opts.version)\n    ) {\n      throw new TypeError('version must be a positive integer number');\n    }\n\n    fields.push(`v=${opts.version}`);\n  }\n\n  // Parameters Validation\n  if (typeof opts.params !== 'undefined') {\n    if (typeof opts.params !== 'object' || opts.params === null) {\n      throw new TypeError('params must be an object');\n    }\n\n    const pk = objectKeys(opts.params);\n    if (!pk.every(p => nameRegex.test(p))) {\n      throw new TypeError(`params names must satisfy ${nameRegex}`);\n    }\n\n    // Convert Numbers into Numeric Strings and Buffers into B64 encoded strings.\n    pk.forEach(k => {\n      if (typeof opts.params[k] === 'number') {\n        opts.params[k] = opts.params[k].toString();\n      } else if (Buffer.isBuffer(opts.params[k])) {\n        opts.params[k] = opts.params[k].toString('base64').split('=')[0];\n      }\n    });\n    const pv = objectValues(opts.params);\n    if (!pv.every(v => typeof v === 'string')) {\n      throw new TypeError('params values must be strings');\n    }\n\n    if (!pv.every(v => valueRegex.test(v))) {\n      throw new TypeError(`params values must satisfy ${valueRegex}`);\n    }\n\n    const strpar = objToKeyVal(opts.params);\n    fields.push(strpar);\n  }\n\n  if (typeof opts.salt !== 'undefined') {\n    // Salt Validation\n    if (!Buffer.isBuffer(opts.salt)) {\n      throw new TypeError('salt must be a Buffer');\n    }\n\n    fields.push(opts.salt.toString('base64').split('=')[0]);\n\n    if (typeof opts.hash !== 'undefined') {\n      // Hash Validation\n      if (!Buffer.isBuffer(opts.hash)) {\n        throw new TypeError('hash must be a Buffer');\n      }\n\n      fields.push(opts.hash.toString('base64').split('=')[0]);\n    }\n  }\n\n  // Create the PHC formatted string\n  const phcstr = fields.join('$');\n\n  return phcstr;\n}\n\n/**\n * Parses data from a PHC string.\n * @param  {string} phcstr A PHC string to parse.\n * @return {Object} The object containing the data parsed from the PHC string.\n */\nfunction deserialize(phcstr) {\n  if (typeof phcstr !== 'string' || phcstr === '') {\n    throw new TypeError('pchstr must be a non-empty string');\n  }\n\n  if (phcstr[0] !== '$') {\n    throw new TypeError('pchstr must contain a $ as first char');\n  }\n\n  const fields = phcstr.split('$');\n  // Remove first empty $\n  fields.shift();\n\n  // Parse Fields\n  let maxf = 5;\n  if (!versionRegex.test(fields[1])) maxf--;\n  if (fields.length > maxf) {\n    throw new TypeError(\n      `pchstr contains too many fileds: ${fields.length}/${maxf}`\n    );\n  }\n\n  // Parse Identifier\n  const id = fields.shift();\n  if (!idRegex.test(id)) {\n    throw new TypeError(`id must satisfy ${idRegex}`);\n  }\n\n  let version;\n  // Parse Version\n  if (versionRegex.test(fields[0])) {\n    version = parseInt(fields.shift().match(versionRegex)[1], 10);\n  }\n\n  let hash;\n  let salt;\n  if (b64Regex.test(fields[fields.length - 1])) {\n    if (fields.length > 1 && b64Regex.test(fields[fields.length - 2])) {\n      // Parse Hash\n      hash = Buffer.from(fields.pop(), 'base64');\n      // Parse Salt\n      salt = Buffer.from(fields.pop(), 'base64');\n    } else {\n      // Parse Salt\n      salt = Buffer.from(fields.pop(), 'base64');\n    }\n  }\n\n  // Parse Parameters\n  let params;\n  if (fields.length > 0) {\n    const parstr = fields.pop();\n    params = keyValtoObj(parstr);\n    if (!objectKeys(params).every(p => nameRegex.test(p))) {\n      throw new TypeError(`params names must satisfy ${nameRegex}`);\n    }\n\n    const pv = objectValues(params);\n    if (!pv.every(v => valueRegex.test(v))) {\n      throw new TypeError(`params values must satisfy ${valueRegex}`);\n    }\n\n    const pk = objectKeys(params);\n    // Convert Decimal Strings into Numbers\n    pk.forEach(k => {\n      params[k] = decimalRegex.test(params[k])\n        ? parseInt(params[k], 10)\n        : params[k];\n    });\n  }\n\n  if (fields.length > 0) {\n    throw new TypeError(`pchstr contains unrecognized fileds: ${fields}`);\n  }\n\n  // Build the output object\n  const phcobj = {id};\n  if (version) phcobj.version = version;\n  if (params) phcobj.params = params;\n  if (salt) phcobj.salt = salt;\n  if (hash) phcobj.hash = hash;\n\n  return phcobj;\n}\n\nmodule.exports = {\n  serialize,\n  deserialize\n};\n"]},"metadata":{},"sourceType":"script"}