{"ast":null,"code":"/**\r\n * Module dependencies.\r\n */\nvar tls; // lazy-loaded...\n\nvar url = require('url');\n\nvar dns = require('dns');\n\nvar Agent = require('agent-base');\n\nvar SocksClient = require('socks').SocksClient;\n\nvar inherits = require('util').inherits;\n/**\r\n * Module exports.\r\n */\n\n\nmodule.exports = SocksProxyAgent;\n/**\r\n * The `SocksProxyAgent`.\r\n *\r\n * @api public\r\n */\n\nfunction SocksProxyAgent(opts) {\n  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);\n  if ('string' == typeof opts) opts = url.parse(opts);\n  if (!opts) throw new Error('a SOCKS proxy server `host` and `port` must be specified!');\n  Agent.call(this, opts);\n  var proxy = Object.assign({}, opts); // prefer `hostname` over `host`, because of `url.parse()`\n\n  proxy.host = proxy.hostname || proxy.host; // SOCKS doesn't *technically* have a default port, but this is\n  // the same default that `curl(1)` uses\n\n  proxy.port = +proxy.port || 1080;\n\n  if (proxy.host && proxy.path) {\n    // if both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete proxy.path;\n    delete proxy.pathname;\n  } // figure out if we want socks v4 or v5, based on the \"protocol\" used.\n  // Defaults to 5.\n\n\n  proxy.lookup = false;\n\n  switch (proxy.protocol) {\n    case 'socks4:':\n      proxy.lookup = true;\n    // pass through\n\n    case 'socks4a:':\n      proxy.version = 4;\n      break;\n\n    case 'socks5:':\n      proxy.lookup = true;\n    // pass through\n\n    case 'socks:': // no version specified, default to 5h\n\n    case 'socks5h:':\n      proxy.version = 5;\n      break;\n\n    default:\n      throw new TypeError('A \"socks\" protocol must be specified! Got: ' + proxy.protocol);\n  }\n\n  if (proxy.auth) {\n    var auth = proxy.auth.split(':');\n    proxy.authentication = {\n      username: auth[0],\n      password: auth[1]\n    };\n    proxy.userid = auth[0];\n  }\n\n  this.proxy = proxy;\n}\n\ninherits(SocksProxyAgent, Agent);\n/**\r\n * Initiates a SOCKS connection to the specified SOCKS proxy server,\r\n * which in turn connects to the specified remote host and port.\r\n *\r\n * @api public\r\n */\n\nSocksProxyAgent.prototype.callback = function connect(req, opts, fn) {\n  var proxy = this.proxy; // called once the SOCKS proxy has connected to the specified remote endpoint\n\n  function onhostconnect(err, result) {\n    if (err) return fn(err);\n    var socket = result.socket;\n    var s = socket;\n\n    if (opts.secureEndpoint) {\n      // since the proxy is connecting to an SSL server, we have\n      // to upgrade this socket connection to an SSL connection\n      if (!tls) tls = require('tls');\n      opts.socket = socket;\n      opts.servername = opts.host;\n      opts.host = null;\n      opts.hostname = null;\n      opts.port = null;\n      s = tls.connect(opts);\n    }\n\n    fn(null, s);\n  } // called for the `dns.lookup()` callback\n\n\n  function onlookup(err, ip) {\n    if (err) return fn(err);\n    options.destination.host = ip;\n    SocksClient.createConnection(options, onhostconnect);\n  }\n\n  var options = {\n    proxy: {\n      ipaddress: proxy.host,\n      port: +proxy.port,\n      type: proxy.version\n    },\n    destination: {\n      port: +opts.port\n    },\n    command: 'connect'\n  };\n\n  if (proxy.authentication) {\n    options.proxy.userId = proxy.userid;\n    options.proxy.password = proxy.authentication.password;\n  }\n\n  if (proxy.lookup) {\n    // client-side DNS resolution for \"4\" and \"5\" socks proxy versions\n    dns.lookup(opts.host, onlookup);\n  } else {\n    // proxy hostname DNS resolution for \"4a\" and \"5h\" socks proxy servers\n    onlookup(null, opts.host);\n  }\n};","map":{"version":3,"sources":["D:/node_modules/npm/node_modules/socks-proxy-agent/index.js"],"names":["tls","url","require","dns","Agent","SocksClient","inherits","module","exports","SocksProxyAgent","opts","parse","Error","call","proxy","Object","assign","host","hostname","port","path","pathname","lookup","protocol","version","TypeError","auth","split","authentication","username","password","userid","prototype","callback","connect","req","fn","onhostconnect","err","result","socket","s","secureEndpoint","servername","onlookup","ip","options","destination","createConnection","ipaddress","type","command","userId"],"mappings":"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","sourcesContent":["/**\r\n * Module dependencies.\r\n */\r\n\r\nvar tls; // lazy-loaded...\r\nvar url = require('url');\r\nvar dns = require('dns');\r\nvar Agent = require('agent-base');\r\nvar SocksClient = require('socks').SocksClient;\r\nvar inherits = require('util').inherits;\r\n\r\n/**\r\n * Module exports.\r\n */\r\n\r\nmodule.exports = SocksProxyAgent;\r\n\r\n/**\r\n * The `SocksProxyAgent`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction SocksProxyAgent(opts) {\r\n  if (!(this instanceof SocksProxyAgent)) return new SocksProxyAgent(opts);\r\n  if ('string' == typeof opts) opts = url.parse(opts);\r\n  if (!opts)\r\n    throw new Error(\r\n      'a SOCKS proxy server `host` and `port` must be specified!'\r\n    );\r\n  Agent.call(this, opts);\r\n\r\n  var proxy = Object.assign({}, opts);\r\n\r\n  // prefer `hostname` over `host`, because of `url.parse()`\r\n  proxy.host = proxy.hostname || proxy.host;\r\n\r\n  // SOCKS doesn't *technically* have a default port, but this is\r\n  // the same default that `curl(1)` uses\r\n  proxy.port = +proxy.port || 1080;\r\n\r\n  if (proxy.host && proxy.path) {\r\n    // if both a `host` and `path` are specified then it's most likely the\r\n    // result of a `url.parse()` call... we need to remove the `path` portion so\r\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\r\n    delete proxy.path;\r\n    delete proxy.pathname;\r\n  }\r\n\r\n  // figure out if we want socks v4 or v5, based on the \"protocol\" used.\r\n  // Defaults to 5.\r\n  proxy.lookup = false;\r\n  switch (proxy.protocol) {\r\n    case 'socks4:':\r\n      proxy.lookup = true;\r\n    // pass through\r\n    case 'socks4a:':\r\n      proxy.version = 4;\r\n      break;\r\n    case 'socks5:':\r\n      proxy.lookup = true;\r\n    // pass through\r\n    case 'socks:': // no version specified, default to 5h\r\n    case 'socks5h:':\r\n      proxy.version = 5;\r\n      break;\r\n    default:\r\n      throw new TypeError(\r\n        'A \"socks\" protocol must be specified! Got: ' + proxy.protocol\r\n      );\r\n  }\r\n\r\n  if (proxy.auth) {\r\n    var auth = proxy.auth.split(':');\r\n    proxy.authentication = { username: auth[0], password: auth[1] };\r\n    proxy.userid = auth[0];\r\n  }\r\n  this.proxy = proxy;\r\n}\r\ninherits(SocksProxyAgent, Agent);\r\n\r\n/**\r\n * Initiates a SOCKS connection to the specified SOCKS proxy server,\r\n * which in turn connects to the specified remote host and port.\r\n *\r\n * @api public\r\n */\r\n\r\nSocksProxyAgent.prototype.callback = function connect(req, opts, fn) {\r\n  var proxy = this.proxy;\r\n\r\n  // called once the SOCKS proxy has connected to the specified remote endpoint\r\n  function onhostconnect(err, result) {\r\n    if (err) return fn(err);\r\n\r\n    var socket = result.socket;\r\n\r\n    var s = socket;\r\n    if (opts.secureEndpoint) {\r\n      // since the proxy is connecting to an SSL server, we have\r\n      // to upgrade this socket connection to an SSL connection\r\n      if (!tls) tls = require('tls');\r\n      opts.socket = socket;\r\n      opts.servername = opts.host;\r\n      opts.host = null;\r\n      opts.hostname = null;\r\n      opts.port = null;\r\n      s = tls.connect(opts);\r\n    }\r\n\r\n    fn(null, s);\r\n  }\r\n\r\n  // called for the `dns.lookup()` callback\r\n  function onlookup(err, ip) {\r\n    if (err) return fn(err);\r\n    options.destination.host = ip;\r\n    SocksClient.createConnection(options, onhostconnect);\r\n  }\r\n\r\n  var options = {\r\n    proxy: {\r\n      ipaddress: proxy.host,\r\n      port: +proxy.port,\r\n      type: proxy.version\r\n    },\r\n    destination: {\r\n      port: +opts.port\r\n    },\r\n    command: 'connect'\r\n  };\r\n\r\n  if (proxy.authentication) {\r\n    options.proxy.userId = proxy.userid;\r\n    options.proxy.password = proxy.authentication.password;\r\n  }\r\n\r\n  if (proxy.lookup) {\r\n    // client-side DNS resolution for \"4\" and \"5\" socks proxy versions\r\n    dns.lookup(opts.host, onlookup);\r\n  } else {\r\n    // proxy hostname DNS resolution for \"4a\" and \"5h\" socks proxy servers\r\n    onlookup(null, opts.host);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"script"}